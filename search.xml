<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何发布自己的npm包</title>
      <link href="/articles/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84npm%E5%8C%85.html"/>
      <url>/articles/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84npm%E5%8C%85.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一下发布过程中遇到的问题</p></blockquote><h3 id="封装自己的-npm-包"><a href="#封装自己的-npm-包" class="headerlink" title="封装自己的 npm 包"></a>封装自己的 npm 包</h3><p>具体封装过程就不写了，注意配置好 package.json，具体如下：</p><pre><code>{    &quot;name&quot;: &quot;yourpkgname&quot;,    &quot;version&quot;: &quot;0.1.0&quot;,    &quot;description&quot;: &quot;description&quot;,    &quot;main&quot;: &quot;dist/index.js&quot;,    &quot;scripts&quot;: {         &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,        &quot;compile&quot;: &quot;./node_modules/.bin/babel src --out-dir dist&quot;, // 将源码编译到dist文件夹，入口文件也要改成dist/index.js        &quot;prepublish&quot;: &quot;npm run compile&quot; // npm publish之前会prepublish    },    &quot;repository&quot;: {         &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/authorname/reponame.git&quot;    },    &quot;bugs&quot;: {         &quot;url&quot;: &quot;https://github.com/authorname/reponame/issues&quot;    },    &quot;homepage&quot;: &quot;https://github.com/authorname/reponame#readme&quot;,    &quot;author&quot;: &quot;authorname&quot;,    &quot;license&quot;: &quot;MIT&quot;,    &quot;devDependencies&quot;: { // 你的依赖    },    &quot;dependencies&quot;: { // 你的依赖    }}</code></pre><h3 id="注册-npm-账号"><a href="#注册-npm-账号" class="headerlink" title="注册 npm 账号"></a>注册 npm 账号</h3><p>在   <a href="https://www.npmjs.com" target="_blank" rel="noopener">https://www.npmjs.com</a>   上面注册一个账号，发布Public Packages，免费用户即可，要想发布 Private Packages,需要$7/User</p><blockquote><p>注册号后一定要去邮箱激活</p></blockquote><h3 id="登录账户"><a href="#登录账户" class="headerlink" title="登录账户"></a>登录账户</h3><p>切换到本地 npm 包目录，登录 npm 账户</p><pre><code>npm adduserusername:password:email:</code></pre><p>依次输入用户名，密码和邮箱，登录成功后可以查看当前登录用户</p><pre><code>npm whoami</code></pre><h3 id="发布-npm-包"><a href="#发布-npm-包" class="headerlink" title="发布 npm 包"></a>发布 npm 包</h3><pre><code>npm publish</code></pre><p>发布成功后，可以在命令行内看到</p><pre><code>+ yourpkgname@0.1.0</code></pre><p>表示已经发布成功，可以去   <a href="https://npmjs/packages/yourpkgname" target="_blank" rel="noopener">https://npmjs/packages/yourpkgname</a>   查看你刚才发布的包</p><h3 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h3><p>先修改本地 package.json 里的 version,再执行发布命令<code>npm publish</code></p><h3 id="使用你的npm包"><a href="#使用你的npm包" class="headerlink" title="使用你的npm包"></a>使用你的npm包</h3><p>在新的项目里面npm i –save yourpkgname，就可以愉快的使用了。</p><h3 id="发布遇到的问题"><a href="#发布遇到的问题" class="headerlink" title="发布遇到的问题"></a>发布遇到的问题</h3><p>1、登录失败</p><p>删除项目目录内的<code>.npmrc</code>文件，重新执行<code>npm adduser</code></p><p>2、发布没有权限</p><pre><code>npm ERR! publish Failed PUT 403npm ERR! code E403npm ERR! You do not have permission to publish &quot;your-package&quot;. Are you logged in as the correct user? : your-package</code></pre><p>你的包名可能和别人的重名了，去npm里搜一下，如果重复改一个名字重新发布</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试常见手写题</title>
      <link href="/articles/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E6%89%8B%E5%86%99%E9%A2%98.html"/>
      <url>/articles/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E6%89%8B%E5%86%99%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><pre><code>function flatten(arr) {    let result = [];    for (let i = 0; i &lt; arr.length; i++) {        if (Array.isArray(arr[i])) {            result = result.concat(flatten(arr[i]));        } else {            result = result.concat(arr[i]);        }    }    return result;}const a = [1, [2, [3, 4]]];console.log(flatten(a));</code></pre><h3 id="prototype-实现继承"><a href="#prototype-实现继承" class="headerlink" title="prototype 实现继承"></a>prototype 实现继承</h3><pre><code>function Foo(name) {    this.name = name;}Foo.prototype.myName = function () {    return this.name;}// 继承属性，通过借用构造函数调用function Bar(name, label) {    Foo.call(this, name);    this.label = label;}// 继承方法，创建备份Bar.prototype = Object.create(Foo.prototype);// 必须设置回正确的构造函数，要不然在会发生判断类型出错Bar.prototype.constructor = Bar;// 必须在上一步之后Bar.prototype.myLabel = function () {    return this.label;}var a = new Bar(&quot;a&quot;, &quot;obj a&quot;);a.myName(); // &quot;a&quot;a.myLabel(); // &quot;obj a&quot;</code></pre><h3 id="获取-URL-参数"><a href="#获取-URL-参数" class="headerlink" title="获取 URL 参数"></a>获取 URL 参数</h3><pre><code>function getQueryVariable(variable){    var query = window.location.search.substring(1);    var vars = query.split(&quot;&amp;&quot;);    for (var i=0;i&lt;vars.length;i++) {            var pair = vars[i].split(&quot;=&quot;);            if(pair[0] == variable){return pair[1];}    }    return(false);}</code></pre><h3 id="Promise-原理"><a href="#Promise-原理" class="headerlink" title="Promise 原理"></a>Promise 原理</h3><pre><code>class MyPromise {    constructor(fn) {        this.resolvedCallbacks = [];        this.rejectedCallbacks = [];        this.state = &apos;PENDING&apos;;        this.value = &apos;&apos;;        fn(this.resolve.bind(this), this.reject.bind(this));    }    resolve(value) {        if (this.state === &apos;PENDING&apos;) {            this.state = &apos;RESOLVED&apos;;            this.value = value;            this.resolvedCallbacks.map(cb =&gt; cb(value));        }    }    reject(value) {        if (this.state === &apos;PENDING&apos;) {            this.state = &apos;REJECTED&apos;;            this.value = value;            this.rejectedCallbacks.map(cb =&gt; cb(value));        }    }    then(onFulfilled, onRejected) {        if (this.state === &apos;PENDING&apos;) {            this.resolvedCallbacks.push(onFulfilled);            this.rejectedCallbacks.push(onRejected);        }        if (this.state === &apos;RESOLVED&apos;) {            onFulfilled(this.value);        }        if (this.state === &apos;REJECTED&apos;) {            onRejected(this.value);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 手写题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序开发遇到的问题总结</title>
      <link href="/articles/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
      <url>/articles/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在小程序的开发中，遇到过不少的坑，总结一下</p></blockquote><p><code>1、wxss中无法使用本地图片当背景图</code></p><p><code>2、关闭开发工具域名校验，可以不在小程序后台配置接口地址，体验版可使用http、ip地址，正式环境必须为https、域名，域名可以带端口号</code></p><p><code>3、按钮始终有描边，&amp;::after{border:none}</code></p><p><code>4、小程序动画api，wx.createAnimation的使用，wx.createSelectorQuery获取节点信息</code></p><p><code>5、在单独的页面使用webview组件，可以跳转外部页面(需配置域名白名单)</code></p><p><code>6、picker组件的range-keyname，需加引号才能正常使用</code></p><p><code>7、wx.previewImage图片预览api，可保存图片和识别图片二维码，目前只能识别小程序二维码</code></p><p><code>8、微信自带弹窗按钮回调无法调起分享api，可通过自定义弹窗，给按钮绑定open-type=&quot;share&quot;</code></p><p><code>9、绑定了open-type的按钮，可同时绑定bindtap点击事件，都可以响应</code></p><p><code>10、wx.navigateTo最多可以跳转十层页面，超过则无法跳转，在不必返回的地方用redirectTo，合理使用这个api</code></p><p><code>11、textarea组件文字滚动时会穿透fixed的元素，需要将fixed元素用cover-view包裹，如果textarea在弹窗里，设置fix，同时设置展示弹窗时才渲染元素</code></p><p><code>12、小程序判断当前环境</code></p><pre><code>let host = &apos;&apos;;console.log(&apos;version&apos;, __wxConfig.envVersion);let env = __wxConfig.envVersion;switch (env) {case &apos;develop&apos;:    host = &apos;https://测试版环境域名&apos;;    break;case &apos;trial&apos;:    host = &apos;https://体验版环境域名&apos;;    break;case &apos;release&apos;:    host = &apos;https://线上环境域名&apos;;    break;default:    host = &apos;https://测试版环境域名&apos;;}console.log(host)</code></pre><p><code>13、cover-view标签自带overflow:hidden;且无法修改，在真机上无效，因为cover-view是原生组件</code></p><p><code>14、小程序transform动画，使用transition-delay时，在真机上会发生抖动</code></p><p><code>15、小程序中部分组件是使用客户端创建的原生组件，包括camera、canvas、input、live-player、live-pusher、 map、textarea、video。原生组件和h5组件在不同层级进行渲染，原生组件层级最高，所以无法修改， 部分样式无法应用。cover-view和cover-image是原生组件，本质就是用原生组件包裹h5组件，从而达到层级可控。 是一种hack做法，最好的解决办法是同层渲染，将原生组件绘制到webview所渲染的html中</code></p><p><code>16、Mac客户端小程序上传图片ApI会对图片名称进行转码，图片前缀为wxfile://tmp_ ,Windows客户端不会对图片名称进行修改，图片前缀为wxfile://temp_</code></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Taro1升级Taro3问题总结</title>
      <link href="/articles/Taro1%E5%8D%87%E7%BA%A7Taro3%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
      <url>/articles/Taro1%E5%8D%87%E7%BA%A7Taro3%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<p><code>1、@taro/mobx用mobx-react替换</code></p><p><code>2、taro-ui需要升级到3.0</code></p><p><code>3、customer-tab-bar引用了taro-ui组件，需要单独引入taro-ui组件样式，且无法使用app.scss中公共样式</code></p><p><code>4、mobx4.0版本搭配mobx-react6.0，去除mobx警告</code></p><p><code>5、去除css引入顺序警告，在config中配置</code></p><pre><code>miniCssExtractPluginOption: {    ignoreOrder: true}</code></pre><p><code>6、公共组件外层标签要写className，否则可能导致渲染出错</code></p><p><code>7、3.0不再支持custom-class，改用props传入className</code></p><p><code>8、文字超出省略失效，加一行代码，否则属性编译后会被干掉，导致样式失效</code></p><pre><code>/* autoprefixer: ignore next */-webkit-box-orient: vertical;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Taro 1 </tag>
            
            <tag> Taro 3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Actions部署hexo博客</title>
      <link href="/articles/Github%20Actions%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2.html"/>
      <url>/articles/Github%20Actions%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装-Deploy-keys-and-Secrets"><a href="#一、安装-Deploy-keys-and-Secrets" class="headerlink" title="一、安装 Deploy keys and Secrets"></a>一、安装 Deploy keys and Secrets</h2><blockquote><p>针对的是存放 Hexo 源文件和网站文件分开存放的场景。</p></blockquote><p>1、 运行以下终端命令，将电子邮件替换为与您的GitHub帐户相连的电子邮件。</p><p>  ssh-keygen -t rsa -C “<a href="mailto:username@example.com" target="_blank" rel="noopener">username@example.com</a>“</p><p>2、在网站文件仓库添加<code>public key</code>。进入<code>Settings &gt; Deploy Keys</code>找到这个选项，可以随意命名公钥，但是需要给它写访问权。</p><p>3、在Hexo源文件仓库添加<code>private key</code>。进入<code>Settings &gt; Secrets</code>中添加一个名叫<code>DEPLOY_KEY</code>的Secret。</p><h2 id="二、Actions脚本"><a href="#二、Actions脚本" class="headerlink" title="二、Actions脚本"></a>二、Actions脚本</h2><pre><code>name: Deployon: [push]jobs:  build:    runs-on: ubuntu-latest    name: A job to deploy blog.    steps:    - name: Checkout      uses: actions/checkout@v1      with:        submodules: true # Checkout private submodules(themes or something else).    # Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.)    - name: Cache node modules      uses: actions/cache@v1      id: cache      with:        path: node_modules        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}        restore-keys: |          ${{ runner.os }}-node-    - name: Install Dependencies      if: steps.cache.outputs.cache-hit != &apos;true&apos;      run: npm install    # Deploy hexo blog website.    - name: Deploy      id: deploy      uses: sma11black/hexo-action@v1.0.0      with:        deploy_key: ${{ secrets.DEPLOY_KEY }}        user_name: your github username        user_email: your github useremail    # Use the output from the `deploy` step(use for test action)    - name: Get the output      run: |        echo &quot;${{ steps.deploy.outputs.notify }}&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github Actions </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript笔记</title>
      <link href="/articles/TypeScript%E7%AC%94%E8%AE%B0.html"/>
      <url>/articles/TypeScript%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、声明文件"><a href="#一、声明文件" class="headerlink" title="一、声明文件"></a>一、声明文件</h2><blockquote><p>当使用第三方库时，我们需要引用它的声明文件。</p></blockquote><h4 id="声明语句"><a href="#声明语句" class="headerlink" title="声明语句"></a>声明语句</h4><p>假如我们想使用第三方库，比如 jQuery，我们通常这样获取一个 id 是 foo 的元素：</p><pre><code>jQuery(&apos;#foo&apos;);// index.ts(1,1): error TS2304: Cannot find name &apos;jQuery&apos;.declare var jQuery: (selector: string) =&gt; any;jQuery(&apos;#foo&apos;);</code></pre><p>declare 定义的类型只会用于编译时的检查，编译结果中会被删除。</p><h4 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h4><p>通常我们会把类型声明放到一个单独的文件中，这就是声明文件：</p><pre><code>// jQuery.d.tsdeclare var jQuery: (string) =&gt; any;</code></pre><blockquote><p>我们约定声明文件以 <code>.d.ts</code> 为后缀。</p></blockquote><p>然后在使用到的文件的开头，用「三斜线指令」表示引用了声明文件：</p><pre><code>/// &lt;reference path=&quot;./jQuery.d.ts&quot; /&gt;jQuery(&apos;#foo&apos;);</code></pre><h4 id="第三方声明文件"><a href="#第三方声明文件" class="headerlink" title="第三方声明文件"></a>第三方声明文件</h4><pre><code>npm install @types/jquery --save-dev</code></pre><h2 id="二、命名空间"><a href="#二、命名空间" class="headerlink" title="二、命名空间"></a>二、命名空间</h2><blockquote><p>“内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与 ECMAScript 2015里的术语保持一致</p></blockquote><pre><code>namespace Utility {  export function log(msg) {    console.log(msg);  }  export function error(msg) {    console.log(msg);  }}// usageUtility.log(&apos;Call me&apos;);Utility.error(&apos;maybe&apos;);</code></pre><p>命名空间：代码层面的归类和管理。将有相似功能的代码都归一到同一个空间下进行管理，方便其他代码引用。更多的是侧重代码的复用。</p><p>模块：一个完整功能的封装，对外提供的是一个具有完整功能的功能包，需要显式引用。一个模块里可能会有多个命名空间。</p><h2 id="三、interface-与-type"><a href="#三、interface-与-type" class="headerlink" title="三、interface 与 type"></a>三、interface 与 type</h2><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><h4 id="都可以描述一个对象或者函数。"><a href="#都可以描述一个对象或者函数。" class="headerlink" title="都可以描述一个对象或者函数。"></a>都可以描述一个对象或者函数。</h4><h5 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h5><pre><code>interface User {  name: string  age: number}interface SetUser {  (name: string, age: number): void;}</code></pre><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><pre><code>type User = {  name: string  age: number};type SetUser = (name: string, age: number): void;</code></pre><h4 id="都允许拓展（extends）"><a href="#都允许拓展（extends）" class="headerlink" title="都允许拓展（extends）"></a>都允许拓展（extends）</h4><blockquote><p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 ==虽然效果差不多，但是两者语法不同。==</p></blockquote><h5 id="interface-extends-interface"><a href="#interface-extends-interface" class="headerlink" title="interface extends interface"></a>interface extends interface</h5><pre><code>interface Name {   name: string; }interface User extends Name {   age: number; }</code></pre><h5 id="type-extends-type"><a href="#type-extends-type" class="headerlink" title="type extends type"></a>type extends type</h5><pre><code>type Name = {   name: string; }type User = Name &amp; { age: number  };</code></pre><h5 id="interface-extends-type"><a href="#interface-extends-type" class="headerlink" title="interface extends type"></a>interface extends type</h5><pre><code>type Name = {   name: string; }interface User extends Name {   age: number; }</code></pre><h5 id="type-extends-interface"><a href="#type-extends-interface" class="headerlink" title="type extends interface"></a>type extends interface</h5><pre><code>interface Name {   name: string; }type User = Name &amp; {   age: number; }</code></pre><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><h5 id="type-可以而-interface-不行"><a href="#type-可以而-interface-不行" class="headerlink" title="type 可以而 interface 不行"></a>type 可以而 interface 不行</h5><blockquote><p>type 可以声明基本类型别名，联合类型，元组等类型</p></blockquote><pre><code>// 基本类型别名type Name = string;// 联合类型type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name {    if (typeof n === &apos;string&apos;) {        return n;    } else {        return n();    }}</code></pre><blockquote><p>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</p></blockquote><pre><code>// 当你想获取一个变量的类型时，使用 typeoflet div = document.createElement(&apos;div&apos;);type B = typeof div</code></pre><h5 id="interface-可以而-type-不行"><a href="#interface-可以而-type-不行" class="headerlink" title="interface 可以而 type 不行"></a>interface 可以而 type 不行</h5><blockquote><p>interface 能够声明合并</p></blockquote><pre><code>interface User {  name: string  age: number}interface User {  sex: string}/*User 接口为 {  name: string  age: number  sex: string }*/</code></pre><p> 一般来说，如果不清楚什么时候用interface/type，能用 interface 实现，就用 interface , 如果不能就用 type </p><h2 id="四、元组"><a href="#四、元组" class="headerlink" title="四、元组"></a>四、元组</h2><blockquote><p>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。</p></blockquote><pre><code>let xcatliu: [string, number];xcatliu[0] = &apos;Xcat Liu&apos;;xcatliu[1] = 25;let xcatliu: [string, number];xcatliu = [&apos;Xcat Liu&apos;, 25];let xcatliu: [string, number] = [&apos;Xcat Liu&apos;];// index.ts(1,5): error TS2322: Type &apos;[string]&apos; is not assignable to type &apos;[string, number]&apos;.//   Property &apos;1&apos; is missing in type &apos;[string]&apos;.</code></pre><h2 id="五、枚举"><a href="#五、枚举" class="headerlink" title="五、枚举"></a>五、枚举</h2><blockquote><p>枚举（Enum）类型用于取值被限定在一定范围内的场景</p></blockquote><p>常量统一使用枚举定义,统一使用全大写加_定义</p><h4 id="数字类型枚举"><a href="#数字类型枚举" class="headerlink" title="数字类型枚举"></a>数字类型枚举</h4><p>枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：</p><pre><code>enum Direction {    Up,    Down,    Left,    Right,}console.log(Drection[&apos;Up&apos;]);    // 0enum Direction {    Up = 1,    Down,    Left,    Right,}console.log(Drection[&apos;Up&apos;]);    // 1enum ECode {  OPERATION_SUCCESS = 10000, // &quot;操作成功&quot;  GAIN_SUCCESS = 10001, // &quot;成功获取数据，数据非空&quot;  GAIN_SUCCESS_EMPTY = 10002, // &quot;操作成功,数据为空&quot;}</code></pre><h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><pre><code>enum EvidenceTypeEnum {  UNKNOWN = &apos;&apos;,  PASSPORT_VISA = &apos;passport_visa&apos;,  PASSPORT = &apos;passport&apos;,  SIGHTED_STUDENT_CARD = &apos;sighted_tertiary_edu_id&apos;,  SIGHTED_KEYPASS_CARD = &apos;sighted_keypass_card&apos;,  SIGHTED_PROOF_OF_AGE_CARD = &apos;sighted_proof_of_age_card&apos;}console.log(EvidenceTypeEnum.PASSPORT); // passport</code></pre><h2 id="六、泛型"><a href="#六、泛型" class="headerlink" title="六、泛型"></a>六、泛型</h2><blockquote><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p></blockquote><p>我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：</p><pre><code>function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}createArray&lt;string&gt;(3, &apos;x&apos;); // [&apos;x&apos;, &apos;x&apos;, &apos;x&apos;]</code></pre><h4 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h4><pre><code>function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] {    return [tuple[1], tuple[0]];}swap([7, &apos;seven&apos;]); // [&apos;seven&apos;, 7]</code></pre><p>我们定义了一个 swap 函数，用来交换输入的元组。</p><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><pre><code>interface CreateArrayFunc&lt;T&gt; {    (length: number, value: T): Array&lt;T&gt;;}let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}createArray(3, &apos;x&apos;); // [&apos;x&apos;, &apos;x&apos;, &apos;x&apos;]</code></pre><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><pre><code>// 创建一个泛型类class Queue&lt;T&gt; {    private data = [];    push = (item: T) =&gt; this.data.push(item);    pop = (): T =&gt; this.data.shift();}</code></pre><h4 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h4><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</p><pre><code>function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}</code></pre><p>你想用它来提供什么样的约束。如果你不能很好的回答它，你可能会误用泛型, 如</p><pre><code>function foo&lt;T&gt;(arg: T): void;</code></pre><p>使用如下方式可能更好</p><pre><code>function foo(arg: any): void;</code></pre><h2 id="七、readonly"><a href="#七、readonly" class="headerlink" title="七、readonly"></a>七、readonly</h2><pre><code>interface IFoo {  readonly name : 1  bar: number  bas: number}// 数组 let foo: ReadonlyArray&lt;number&gt; = [1, 2, 3]console.log(foo[0]) // okfoo.push(4); // Error: ReadonlyArray 上不存在push，因为他会改变数组foo = foo.concat(4) // ok, 创建了一个复制// 项目统一使用import React, { PureComponent } from &apos;react&apos;const initialState = {}interface IProps {}interface IState {}export default class Demo extends PureComponent&lt;IProps, IState&gt; {   readonly state: IState = initialState   render() {       return (           &lt;div&gt;&lt;/div&gt;       )   }}</code></pre><h4 id="与-const-的不同"><a href="#与-const-的不同" class="headerlink" title="与 const 的不同"></a>与 <code>const</code> 的不同</h4><p><code>const</code></p><ul><li>用于常量；</li></ul><p><code>readonly</code></p><ul><li>用于属性；</li></ul><pre><code>const foo = 123; // 变量let bar: {  readonly len: number; // 属性};</code></pre><h2 id="八、联合类型"><a href="#八、联合类型" class="headerlink" title="八、联合类型"></a>八、联合类型</h2><blockquote><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p></blockquote><pre><code>interface ISquare {  kind: &apos;square&apos;  size: number}interface IRectangle {  kind: &apos;rectangle&apos;  width: number  height: number}type TShape = ISquare | IRectangle// 条件判断function area(s: TShape) {  if (s.kind === &apos;square&apos;) {    // 现在 TypeScript 知道 s 的类型是 Square    // 所以你现在能安全使用它    return s.size * s.size  }  // 不是一个 square ？因此 TypeScript 将会推算出 s 一定是 Rectangle  return s.width * s.height}//  switchfunction area(s: TShape) {  switch (s.kind) {    case &apos;square&apos;:      return s.size * s.size;    case &apos;rectangle&apos;:      return s.width * s.height;    default:      const _exhaustiveCheck: never = s;  }}area({kind:&apos;square&apos;, size: 1})area({kind:&apos;rectangle&apos;, size: 1}) // Errorarea({kind:&apos;rectangle&apos;, width: 1, height: 2})area({kind:&apos;square&apos;, width: 1, height: 2}) // Error</code></pre><h2 id="九、类是有用的"><a href="#九、类是有用的" class="headerlink" title="九、类是有用的"></a>九、类是有用的</h2><pre><code>function foo() {  let someProperty;  // 一些其他的初始化代码  function someMethod() {    // 用 someProperty 做一些事情    // 可能有其他属性  }  // 可能有其他的方法  return {    someMethod    // 可能有其他方法  };};</code></pre><p>上面是在应用中常见的闭包，可以使用类的方式来重写</p><pre><code>class Foo {  public someProperty;  constructor() {    // 一些初始化内容  }  public someMethod() {    // ..code  }  public someUtility() {    // .. code  }}export = new Foo();</code></pre><p>这并不仅仅有利于开发者，在创建基于类的更出色可视化工具中，它更常见。并且，这有利于项目的理解和维护。</p><h2 id="十、明确的类型转换"><a href="#十、明确的类型转换" class="headerlink" title="十、明确的类型转换"></a>十、明确的类型转换</h2><pre><code>if (123) {  // 将会被推断出 `true`  console.log(&apos;Any number other than 0 is truthy&apos;);}</code></pre><p>通过操作符 <code>!!</code>，你可以很容易的将某些值转化为布尔类型的值。</p><pre><code>// Direct variablesconst hasName = !!name;// As members of objectsconst someObj = {  hasName: !!name};// ReactJS{  !!someName &amp;&amp; &lt;div&gt;{someName}&lt;/div&gt;;}</code></pre><h2 id="十一、函数参数"><a href="#十一、函数参数" class="headerlink" title="十一、函数参数"></a>十一、函数参数</h2><p>如果一个函数含有很多参数或者相同类型参数，可以使用对象的形式来替代这些函数参数：</p><pre><code>function foo(flagA: boolean, flagB: boolean) {  // 函数主体}</code></pre><p>像这样的函数，你可能会很容易错误的调用它，如 foo(flagB, flagA)，并且你并不会从编译器得到想要的帮助。</p><p>使用接收一个对象参数的形式：</p><pre><code>function foo(  config: {    flagA: boolean;    flagB: boolean;  }) {  const { flagA, flagB } = config;}</code></pre><p>现在，函数将会被 foo({ flagA, flagB }) 的形式调用，这样有利于发现错误及代码审查。</p><h2 id="十二、对象字面量的惰性初始化"><a href="#十二、对象字面量的惰性初始化" class="headerlink" title="十二、对象字面量的惰性初始化"></a>十二、对象字面量的惰性初始化</h2><p>在 JavaScript 中，像这样用字面量初始化对象的写法十分常见：</p><pre><code>let foo = {};foo.bar = 123;foo.bas = &apos;Hello World&apos;;</code></pre><p>但在 TypeScript 中，同样的写法就会报错：</p><pre><code>let foo = {};foo.bar = 123; // Error: Property &apos;bar&apos; does not exist on type &apos;{}&apos;foo.bas = &apos;Hello World&apos;; // Error: Property &apos;bas&apos; does not exist on type &apos;{}&apos;</code></pre><p>这是因为 TypeScript 在解析 let foo = {} 这段赋值语句时，会进行“类型推断”：它会认为等号左边 foo 的类型即为等号右边 {} 的类型。由于 {} 本没有任何属性，因此，像上面那样给 foo 添加属性时就会报错。</p><pre><code>// 最好的解决方案let foo = {  bar: 123,  bas: &apos;Hello World&apos;};// 折中方案interface Foo {  bar: number;  bas: string;}let foo = {} as Foo;foo.bar = 123;foo.bas = &apos;Hello World&apos;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GraphQL入门</title>
      <link href="/articles/GraphQL%E5%85%A5%E9%97%A8.html"/>
      <url>/articles/GraphQL%E5%85%A5%E9%97%A8.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是GraphQL"><a href="#一、什么是GraphQL" class="headerlink" title="一、什么是GraphQL"></a>一、什么是GraphQL</h3><p>GraphQL 是Facebook开发的API查询语言，而不是一个数据库。</p><p>GraphQL 是基于API之上的一层封装，目的是为了更好，更灵活的适用于业务的需求变化。</p><p>GraphQL 是一套API规范，只要按照规范设计，它可以运行在任何后端框架或者编程语言之上。</p><h3 id="二、为什么使用GraphQL"><a href="#二、为什么使用GraphQL" class="headerlink" title="二、为什么使用GraphQL"></a>二、为什么使用GraphQL</h3><ul><li><p>即使提前跟后端沟通好接口数据字段，实际开发过程中还是会发生接口少字段或多字段</p></li><li><p>多端公用一套数据接口时，数据冗余度高</p></li><li><p>前端的快速产品迭代对API有很大的挑战，改动成本很高</p></li><li><p>GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 RESTful API 架构中那样需要多次往返查询。</p></li></ul><h3 id="三、基本概念"><a href="#三、基本概念" class="headerlink" title="三、基本概念"></a>三、基本概念</h3><ul><li>字段（Fields）</li><li>参数（Arguments）</li><li>操作名称（Operation name）</li><li>变量（Variables）</li></ul><h4 id="1、字段"><a href="#1、字段" class="headerlink" title="1、字段"></a>1、字段</h4><blockquote><p>Field是我们想从服务器获取的对象的基本组成部分。</p></blockquote><pre><code>// 查询语句{  hello  todolist{    id  }}// 查询结果{  &quot;data&quot;: {    &quot;hello&quot;: &quot;hello world&quot;,    &quot;todolist&quot;: [      {        &quot;id&quot;: &quot;1&quot;      },      {        &quot;id&quot;: &quot;2&quot;      }    ]  }}</code></pre><p>可以看到查询和其结果拥有一样的结构，这是 GraphQL 最重要的特性，需要什么数据就拿什么数据。</p><p>todolist 返回了一个数组的项目，GraphQL 查询会同等看待单个项目或者一个列表的项目，具体通过 schema 决定</p><h4 id="2、参数"><a href="#2、参数" class="headerlink" title="2、参数"></a>2、参数</h4><blockquote><p>字段可以传递参数，参数是可选的</p></blockquote><pre><code>// 查询语句{  hello(name:&quot;GraphQL&quot;)  todolist{    id  }}// 查询结果{  &quot;data&quot;: {    &quot;hello&quot;: &quot;hello GraphQL&quot;,    &quot;todolist&quot;: [      {        &quot;id&quot;: &quot;1&quot;      },      {        &quot;id&quot;: &quot;2&quot;      }    ]  }}</code></pre><p>在RESTful API 的系统中，你只能传递一组简单参数。但是在 GraphQL 中，每一个字段和嵌套对象都能有自己的一组参数，从而使得 GraphQL 可以完美替代多次 API 获取请求。</p><pre><code>// 查询语句{  hello(name:&quot;GraphQL&quot;)  item(id:2){    id,    item_name,    status  }}// 查询结果{  &quot;data&quot;: {    &quot;hello&quot;: &quot;hello GraphQL&quot;,    &quot;item&quot;: {      &quot;id&quot;: &quot;2&quot;,      &quot;item_name&quot;: &quot;GraphQl入门&quot;,      &quot;status&quot;: true    }  }}</code></pre><p>需要注意的是，GraphQL中的字符串需要包装在双引号中。</p><h4 id="3、操作名称"><a href="#3、操作名称" class="headerlink" title="3、操作名称"></a>3、操作名称</h4><blockquote><p>类似函数的名称，使你的操作的有意义和明确的名称</p></blockquote><p>不写默认为query查询</p><p>操作类型的关键字 query 以及操作名称 list</p><pre><code>// 查询语句query list{  todolist{    id,    item_name,    status  }}// 查询结果{  &quot;data&quot;: {    &quot;todolist&quot;: [      {        &quot;id&quot;: &quot;1&quot;,        &quot;item_name&quot;: &quot;深入理解TypeScript&quot;,        &quot;status&quot;: false      },      {        &quot;id&quot;: &quot;2&quot;,        &quot;item_name&quot;: &quot;GraphQl入门&quot;,        &quot;status&quot;: true      }    ]  }}</code></pre><p>操作名称可以使我们代码减少歧义，方便查错和调试，开发中建议强制书写。</p><p>注意：使用查询简写语法的情况下，你无法为操作提供名称或变量定义。</p><h4 id="4、变量"><a href="#4、变量" class="headerlink" title="4、变量"></a>4、变量</h4><blockquote><p>使用变量来让参数可动态变化，变量以$开头书写</p></blockquote><pre><code>query hello($name: String!) {    hello(name: $name)}</code></pre><p>参数可以拥有默认值：</p><pre><code>query hello($name: String! = &quot;world&quot;) {    hello(name: $name)}</code></pre><h3 id="四、操作类型"><a href="#四、操作类型" class="headerlink" title="四、操作类型"></a>四、操作类型</h3><p>GraphQL的三种操作类型Query、Mutation、Subscription</p><h4 id="Query-查询"><a href="#Query-查询" class="headerlink" title="Query (查询)"></a>Query (查询)</h4><blockquote><p>query是GraphQL 中的获取数据的方式，需要什么数据获取什么数据</p></blockquote><h4 id="Mutation-变更、增删改"><a href="#Mutation-变更、增删改" class="headerlink" title="Mutation (变更、增删改)"></a>Mutation (变更、增删改)</h4><blockquote><p>更改是修改服务器上的数据并获取更新数据的方式</p></blockquote><p>mutation被用以执行写操作，通过mutation我们会给服务器发送请求来修改和更新数据，并且会接收更新的数据。</p><pre><code>// 修改mutation updata{  updateItem(id: 3, item_name: &quot;小程序IM&quot;, status: true) {    id    item_name    status  }}// 返回{  &quot;data&quot;: {    &quot;updateItem&quot;: {      &quot;id&quot;: &quot;3&quot;,      &quot;item_name&quot;: &quot;小程序IM&quot;,      &quot;status&quot;: true    }  }}</code></pre><p>为了保证数据的完整性mutation是串形执行，而query可以并行执行。</p><h4 id="Subscription-订阅"><a href="#Subscription-订阅" class="headerlink" title="Subscription (订阅)"></a>Subscription (订阅)</h4><blockquote><p>实时通信业务的需求,可以实现服务端对客户端的实时数据传递</p></blockquote><pre><code>subscription {  todolist {    id    item_name    status  }}</code></pre><h3 id="五、Schema（模式）"><a href="#五、Schema（模式）" class="headerlink" title="五、Schema（模式）"></a>五、Schema（模式）</h3><blockquote><p>描述可以查询到的数据的结构</p></blockquote><pre><code>type TodoItem {    id: ID!    item_name: String!    status: Boolean!}type Query {    hello(name:String = &quot;world&quot;): String    todolist: [TodoItem!]!    item(id: ID!): TodoItem!}type Mutation {    createItem(id: ID!, item_name: String!, status: Boolean!): TodoItem!    updateItem(id: ID!, item_name: String, status: Boolean!): TodoItem!    deleteItem(id: ID!): TodoItem!}</code></pre><p><code>！</code>表示非空 ，<code>[]</code>  列表类型，也就是数组</p><p>每一个 GraphQL 服务都会定义一套类型，用以描述你可能从那个服务查询到的数据。每次查询，服务器就会根据 schema 验证并执行查询。</p><h3 id="六、Type（类型）"><a href="#六、Type（类型）" class="headerlink" title="六、Type（类型）"></a>六、Type（类型）</h3><blockquote><p>类型是 GraphQL 最重要的特性之一</p></blockquote><h4 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h4><pre><code>type TodoItem {    id: ID!    item_name: String!    status: Boolean!}</code></pre><h4 id="标量类型（Scalar-Types）"><a href="#标量类型（Scalar-Types）" class="headerlink" title="标量类型（Scalar Types）"></a>标量类型（Scalar Types）</h4><blockquote><p>GraphQL 查询的叶子节点，没有任何次级字段，类似js中的基本类型</p></blockquote><p>GraphQL 自带一组默认标量类型：</p><ul><li>Int：有符号 32 位整数。</li><li>Float：有符号双精度浮点值。</li><li>String：UTF‐8 字符序列。</li><li>Boolean：true 或者 false。</li><li>ID：ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。ID 类型使用和 String 一样的方式序列化；然而将其定义为 ID 意味着并不需要人类可读型。</li></ul><h4 id="自定义标量"><a href="#自定义标量" class="headerlink" title="自定义标量"></a>自定义标量</h4><pre><code>sclar Date</code></pre><p>除了标量类型还有枚举、列表和非空、接口interface、联合类型、输入类型等</p><p>输入对象看上去和常规对象一模一样，除了关键字是 input 而不是 type，输入对象类型的字段当然也不能拥有参数。</p><p>类型系统除了可以让我们清楚的了解获取的数据类型，也可以在请求数据类型出错时，触发一个 GraphQL 执行错误，以让客户端知道发生了错误。而不需要后端去处理这种类型错误</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>网络开销低，可以在单一请求中获取REST中使用多条请求获取的资源</li><li>强类型Schema（约束意味着可以根据规范形成文档、IDE、错误提示等生态工具）</li><li>特别适合图状数据结构的业务场景（比如好友、流程、组织架构等系统）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GraphQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React.lazy懒加载组件</title>
      <link href="/articles/React-lazy%E6%87%92%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6.html"/>
      <url>/articles/React-lazy%E6%87%92%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了应用的性能，我们通常都会使用code splitting，当前大部分 React 应用都选择使用 react-loadable 来处理。然而，React 16.6添加了一个新的特性: React.lazy(), 它可以让代码分割(code splitting)更加容易。</p></blockquote><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre><code>const OtherComponent = React.lazy(() =&gt; import(&apos;./OtherComponent&apos;));function MyComponent() {  return (    &lt;div&gt;      &lt;OtherComponent /&gt;    &lt;/div&gt;  );}</code></pre><p>React.lazy()接收一个匿名函数作为参数，在函数中动态引入<code>&lt;OtherComponent /&gt;</code>组件。这样在我们渲染这个组件前，浏览器将不会下载<code>&lt;OtherComponent /&gt;</code>组件和它的依赖。</p><p>React.lazy()目前仅支持默认导出</p><h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><p>如果React要渲染<code>&lt;OtherComponent /&gt;</code>组件时，组件依赖的代码还没下载好，我们需要展示一些提示内容，在等待组件加载的时候，这时我们就需要用到<code>React.Suspense</code>组件。</p><pre><code>const OtherComponent = React.lazy(() =&gt; import(&apos;./OtherComponent&apos;));function MyComponent() {  return (    &lt;React.Suspense fallback={&lt;Spinner /&gt;}&gt;      &lt;OtherComponent /&gt;    &lt;/React.Suspense&gt;  );}</code></pre><p><code>React.Suspense</code>接收任何类型的<code>React</code>元素，以便在我们等待异步加载时进行渲染。</p><p>在代码未下载好前，<code>React.Suspense</code>将会渲染<code>fallback</code> props属性传入的值，当全部子节点依赖的代码都准备好后，才会去渲染子节点内容。</p><h3 id="加载出错的处理"><a href="#加载出错的处理" class="headerlink" title="加载出错的处理"></a>加载出错的处理</h3><p>如果其他模块无法加载（例如，由于网络故障），则会触发错误，可以使用<code>Error Boundary</code>处理这些错误以显示良好的用户体验。</p><pre><code>import MyErrorBoundary from &apos;./MyErrorBoundary&apos;;const OtherComponent = React.lazy(() =&gt; import(&apos;./OtherComponent&apos;));const MyComponent = () =&gt; (  &lt;div&gt;    &lt;MyErrorBoundary&gt;      &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;        &lt;OtherComponent /&gt;      &lt;/Suspense&gt;    &lt;/MyErrorBoundary&gt;  &lt;/div&gt;);</code></pre><h3 id="与react-loadable对比"><a href="#与react-loadable对比" class="headerlink" title="与react-loadable对比"></a>与react-loadable对比</h3><p>在react-loadable 当中，按需加载可能在长这样：</p><pre><code>const Loading = ({ pastDelay }) =&gt; {  if (pastDelay) {    return &lt;Spinner /&gt;;  }  return null;};export const LoadingComponent = Loadable({  loader: () =&gt; import(&apos;./OtherComponent&apos;),  loading: Loading,  delay: 200});</code></pre><p>在上面的代码中，我们做了几个事情：</p><ul><li>我们定义一个 Loading 组件，用于在请求组件的时间和加载组件以及准备渲染之间显示。</li><li>LoadingComponent 中的loading参数是在请求/响应周期中显示的组件，这里我们定义了一个 自定义Loading组件</li><li>设置了一个delay，我们只在加载超过 200 毫秒的时候显示Spinner ，这样做可以很好地避免在请求快速完成时“闪烁”加载中的组件。</li></ul><p>使用 <code>React.Suspense</code> 显然代码更为优雅。</p><pre><code>const OtherComponent = React.lazy(() =&gt; import(&apos;./OtherComponent&apos;));export const MyComponent = props =&gt; (  &lt;React.Suspense fallback={&lt;Spinner /&gt;}&gt;    &lt;OtherComponent {...props} /&gt;  &lt;/React.Suspense&gt;);</code></pre><p>到此，其实我们已经实现了和 <code>react-loadable</code> 一样的功能。仔细看我们会发现，<code>React.Suspense</code>没有 <code>delay</code> 参数。目前<code>React.Suspense</code>没有在内置支持<code>delay</code> 功能，如果资源被加载得非常快得话，加载动画可能会出现闪一下，为了避免这种情况，我们需要自己在 <code>fallback</code> 的组件中自行处理这些逻辑，例如在 <code>componentDidMount</code> 中设置一个定时器，使其直到将来的某个时间才呈现。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>去除了第三方的库，我们打包的体积可以变的更小。</p></li><li><p>使用 <code>React</code> 的核心库，总比第三方库更容易维护。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> react.lazy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React + Next.js + antd-mobile 服务端渲染实践</title>
      <link href="/articles/React%20+%20Next.js%20+%20antd-mobile%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5.html"/>
      <url>/articles/React%20+%20Next.js%20+%20antd-mobile%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5.html</url>
      
        <content type="html"><![CDATA[<h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>服务端渲染，是指页面的渲染和生成由服务器来完成，并将渲染好的页面返回客户端。而客户端渲染是页面的生成和数据的渲染过程是在客户端（浏览器或APP）完成。</p><h3 id="Next-js-简介"><a href="#Next-js-简介" class="headerlink" title="Next.js 简介"></a>Next.js 简介</h3><p>Next.js是一个基于React的一个服务端渲染简约框架。它使用React语法，可以很好的实现代码的模块化，有利于代码的开发和维护。</p><h3 id="Next-js主要功能"><a href="#Next-js主要功能" class="headerlink" title="Next.js主要功能"></a>Next.js主要功能</h3><ul><li>热代码更新: 检测磁盘文件更新即更新整个页面</li><li>自动路由: 映射文件系统路径至任意URL地址，无需任何配置</li><li>单文件组件: 使用自身集成的styled-jsx，可以给组件直接添加样式</li><li>服务端渲染: 发送html之前，你可以选择性在服务端渲染React组件</li><li>生态系统兼容: next.js与js、node、react生态系统协作良好</li><li>自动代码分割: 页面只会加载需要的js文件资源</li><li>预读取: Link链接组件，支持prefetch属性用于后台自动预读取页面资源，包括代码分割丢失的代码</li><li>动态组件: 支持动态导入JS文件和React组件</li><li>静态输出: 使用next export命令，可以输出APP为静态站点</li></ul><h3 id="安装Next-js"><a href="#安装Next-js" class="headerlink" title="安装Next.js"></a>安装Next.js</h3><pre><code>npm install --save next react react-dom</code></pre><p>创建package.json文件</p><pre><code>{  &quot;scripts&quot;: {    &quot;dev&quot;: &quot;next&quot;  }}</code></pre><p>创建空pages目录，执行npm run dev命令，next.js会在localhost:3000启动本地服务。</p><p>默认首页指向404页面，next.js也可以处理500状态。</p><h3 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h3><p>在pages目录中创建index.js, 写一个简单React纯函数组件</p><pre><code>export default () =&gt; (  &lt;div&gt;    &lt;h1&gt;Hello World!&lt;/h1&gt;  &lt;/div&gt;)</code></pre><p>此时在localhost:3000，可以看到Hello World！页面<br>如果访问服务端，组件会自动加载。</p><p>next.js使用基于文件系统结构的声明式页面结构，文件系统路径就是页面API。</p><p>打开页面源码，查看View-&gt;Developer-&gt;View Source, 页面源码显示的是组件生成由服务端渲染的html元素。</p><h3 id="多页面创建"><a href="#多页面创建" class="headerlink" title="多页面创建"></a>多页面创建</h3><p>在 pages 目录下创建文件 pages/about.js :</p><pre><code>export default () =&gt; (  &lt;div&gt;    &lt;p&gt;This is the about page&lt;/p&gt;  &lt;/div&gt;)</code></pre><h3 id="热刷新"><a href="#热刷新" class="headerlink" title="热刷新"></a>热刷新</h3><p>无须手动重启npm进程，next.js会在后台自动完成。</p><h3 id="Link组件"><a href="#Link组件" class="headerlink" title="Link组件"></a>Link组件</h3><p>服务端渲染在首页面加载会十分方便，但当导航至网站内部页面时，客户端渲染是加速页面加载的关键，能提升用户体验。</p><p>Next.js提供Link组件用来创建链接，可以上述示例中创建链接：</p><pre><code>import Link from &apos;next/link&apos;export default () =&gt; (  &lt;div&gt;    &lt;h1&gt;Hello World!&lt;/h1&gt;    &lt;Link href=&quot;/about&quot;&gt;      &lt;a&gt; About Page&lt;/a&gt;    &lt;/Link&gt;  &lt;/div&gt;)</code></pre><p>在浏览器中访问首页 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a> 时，点击 About Page即可跳转到about页面，点击浏览器返回按钮还可以返回到index页面。</p><p>Link组件是通过location.history的浏览器API保存历史路由，所以，你可以通过浏览器左上角的前进和后退按钮来切换历史路由。而在开发过程中，你不需要再单独写客户端路由的配置。</p><p>Link组件是React的高阶组件的实现，不能对它进行样式的设置，它只是起到路由的跳转功能，但是它的复用性强，只要包含一个能触发onClick事件的组件即可。</p><h3 id="动态页面"><a href="#动态页面" class="headerlink" title="动态页面"></a>动态页面</h3><p>博客是next.js非常好的案例。动态页面没有固定内容，会基于某些参数渲染部分数据。</p><pre><code>import Link from &apos;next/link&apos;const Post = (props) =&gt; (  &lt;li&gt;    &lt;Link href={`/post?title=${props.title}`}&gt;      &lt;a&gt;{props.title}&lt;/a&gt;    &lt;/Link&gt;  &lt;/li&gt;)export default () =&gt; (  &lt;div&gt;    &lt;h2&gt;My blog&lt;/h2&gt;    &lt;ul&gt;      &lt;Post title=&quot;Yet another post&quot; /&gt;      &lt;Post title=&quot;Second post&quot; /&gt;      &lt;Post title=&quot;Hello, world!&quot; /&gt;    &lt;/ul&gt;  &lt;/div&gt;)</code></pre><p>组件会创建一系列的文章链接，文章标题附加查询参数。</p><p>可以在page目录中创建post.js文件:</p><pre><code>export default (props) =&gt; (  &lt;h1&gt;{props.url.query.title}&lt;/h1&gt;)</code></pre><h3 id="获取数据以及组件生命周期"><a href="#获取数据以及组件生命周期" class="headerlink" title="获取数据以及组件生命周期"></a>获取数据以及组件生命周期</h3><p>Next.js 在 React 的基础上为组件添加了一个新的特性： getInitialProps （有点像是getInitialState），它用于获取并处理组件的属性，返回组件的默认属性。我们可以在改方法中请求数据，获取页面需要的数据并渲染返回给前端页面。</p><p>安装发送 fetch 请求的插件 isomorphic-unfetch，当然你也可以使用 axios 等其他工具。</p><pre><code>npm install --save isomorphic-unfetch</code></pre><p>然后修改 pages/index.js 里的内容，换成下面这样：</p><pre><code>import Layout from &apos;../components/Layout&apos;import { Button } from &apos;antd-mobile&apos;import Link from &apos;next/link&apos;import fetch from &apos;isomorphic-unfetch&apos;const Index = props =&gt; (  &lt;Layout title=&quot;Index&quot;&gt;    &lt;ul&gt;      {props.shows.map(({show}) =&gt; (        &lt;li key={show.id}&gt;          &lt;Link as={`/p/${show.id}`} href={`/post?id=${show.id}`}&gt;            &lt;a&gt;{show.name}&lt;/a&gt;          &lt;/Link&gt;        &lt;/li&gt;      ))}    &lt;/ul&gt;    &lt;Link href=&quot;/about&quot;&gt;      &lt;Button&gt;Go to About&lt;/Button&gt;    &lt;/Link&gt;  &lt;/Layout&gt;)Index.getInitialProps = async function() {  const res = await fetch(&apos;https://api.tvmaze.com/search/shows?q=batman&apos;)  const data = await res.json()  console.log(`服务端获取数据！`)  return {    shows: data  }}export default Index</code></pre><p>在 getInitialProps 中使用了 async 和 await 来处理异步请求，并将取到的数据当做一个属性赋给页面，页面拿到这个属性的值后会用于页面的初始化渲染。</p><h3 id="使用样式"><a href="#使用样式" class="headerlink" title="使用样式"></a>使用样式</h3><p>next.js默认支持styled-jsx, 生成独立作用域的 CSS，当前组件的样式只在组件内部生效，对子组件也没有影响。</p><p>如果想对子组件也生效，可以给style标签添加global属性。</p><p>对上述代码添加样式，放在组件内部即可：</p><pre><code>&lt;style jsx&gt;{`  h1, a {    font-family: &quot;Arial&quot;;  }  ul {    padding: 0;  }  li {    list-style: none;    margin: 5px 0;  }  a {    text-decoration: none;    color: blue;  }  a:hover {    opacity: 0.6;  }`}&lt;/style&gt;</code></pre><h3 id="添加antd-mobile"><a href="#添加antd-mobile" class="headerlink" title="添加antd-mobile"></a>添加antd-mobile</h3><p>首先安装antd-mobile和next解析外部css文件的插件@zeit/next-css</p><pre><code>npm install --save antd-mobile @zeit/next-css</code></pre><p>安装按需加载插件</p><pre><code>npm install --save babel-plugin-import</code></pre><p>添加.babelrc文件，并加入如下代码：</p><pre><code>{  &quot;presets&quot;: [&quot;next/babel&quot;],  &quot;plugins&quot;: [    [      &quot;import&quot;,      {        &quot;libraryName&quot;: &quot;antd-mobile&quot;,        &quot;style&quot;: &quot;css&quot;      }    ]  ]}</code></pre><p>添加next.config.js文件，可以在该文件内自定义next的配置，比如扩展webpack</p><p>注意：next.config.js是一个 Node.js 模块，不是一个 JSON 文件，可以用于 Next 启动服务已经构建阶段，但是不作用于浏览器端。</p><p>添加如下代码：</p><pre><code>const withCSS = require(&apos;@zeit/next-css&apos;)// fix: prevents error when .css files are required by nodeif (typeof require !== &apos;undefined&apos;) {  // eslint-disable-next-line  require.extensions[&apos;.css&apos;] = (file) =&gt; {}}module.exports = withCSS()</code></pre><p>这样，我们就可以在组件中使用antd-mobile框架了</p><p>更多代码请参见<a href="https://github.com/NeuronGenius/UEX.Blog/tree/master/examples/next-demo" target="_blank" rel="noopener">example</a></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> next </tag>
            
            <tag> antd-mobile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React常用组件模式</title>
      <link href="/articles/React%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F.html"/>
      <url>/articles/React%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习 React 开发也有一段时间了，各种各样的设计模式及新概念亦层出不穷。这里总结一下 React 开发中一些常见的设计模式。</p></blockquote><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><ul><li>有状态组件 vs 无状态组件</li><li>容器组件 vs 展示组件</li><li>高阶组件 vs 回调渲染组件</li></ul><h3 id="有状态组件-vs-无状态组件"><a href="#有状态组件-vs-无状态组件" class="headerlink" title="有状态组件 vs 无状态组件"></a>有状态组件 vs 无状态组件</h3><p>正如 WEB 服务有静态和动态之分，React 组件也有有状态和无状态的区分。</p><ul><li>有状态组件：在应用中组件可以拥有自身状态并操纵它。</li><li>无状态组件：只接收属性进行效果呈现。</li></ul><p>一个简单的无状态组件，只受属性控制:</p><pre><code>const Button = props =&gt; (  &lt;button onClick={props.onClick}&gt;    {props.text}  &lt;/button&gt;);</code></pre><p>一个具有计数功能的按钮组件 (复用上面 Button 组件)</p><pre><code>class ButtonCounter extends React.Component {  constructor() {    super()    this.state = {clicks: 0}    this.handleClick = this.handleClick.bind(this)  }  handleClick() {    this.setState({clicks: this.state.clicks + 1})  }  render() {    return (      &lt;Button        onClick={this.handleClick}        text={`You&apos;ve clicked me ${this.state.clicks} times!`}      /&gt;    )  }}</code></pre><p>正如上面两个 Demo 所示，第二个组件的 constructor 具有状态的定义，第一个组件只是单纯地渲染属性文字。有状态组件和无状态组件的划分看起来非常简单，但是它对于组件复用具有重大意义。</p><h3 id="容器组件-vs-展示组件"><a href="#容器组件-vs-展示组件" class="headerlink" title="容器组件 vs 展示组件"></a>容器组件 vs 展示组件</h3><p>当组件需要获取外部数据时，我们又可以将组件划分为两种新的类型。容器组件负责获取数据，它常常是超出了 React 范畴的，如使用 Redux 或 Relay 进行了绑定。对比而言，展示型组件不依赖于程序其他部分，它只和自身状态或属性有关。下面我们实现一个用户列表的展示组件:</p><pre><code>const UserList = props =&gt;  &lt;ul&gt;    {props.users.map(u =&gt; (      &lt;li&gt;{u.name} — {u.age} years old&lt;/li&gt;    ))}  &lt;/ul&gt;</code></pre><p>容器组件可以用来更新用户列表的展示:</p><pre><code>class UserListContainer extends React.Component {  constructor() {    super()    this.state = {users: [] }  }  componentDidMount() {    fetchUsers(users =&gt; this.setState({ users }))  }  render() {    return &lt;UserList users={this.state.users} /&gt;  }}</code></pre><p>这种分类将数据获取和渲染的逻辑分开，进而使用户列表组件可以复用。</p><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><p>当你想复用组件逻辑时，高阶组件非常有用。高阶组件：是将组件作为参数并返回新组件的 JS 函数。</p><p>假设你需要构建一个可扩展菜单组件，当用户点击时，它会显示隐藏子组件内容。因此，你可以使用高阶组件来实现:</p><pre><code>function makeToggleable(Clickable) {  return class extends React.Component {    constructor() {      super()      this.toggle = this.toggle.bind(this)      this.state = {show: false}    }    toggle() {      this.setState(prevState =&gt; ({ show: !prevState.show }))    }    render() {      return (        &lt;div&gt;          &lt;Clickable            {...this.props}            onClick={this.toggle}          /&gt;          {this.state.show &amp;&amp; this.props.children}        &lt;/div&gt;      )    }  }}</code></pre><p>这种方法允许我们使用 ES7 装饰器语法将逻辑应用于 ToggleableMenu 组件:</p><pre><code>@makeToggleableclass ToggleableMenu extends React.Component {  render() {    return (      &lt;div onClick={this.props.onClick}&gt;        &lt;h1&gt;{this.props.title}&lt;/h1&gt;      &lt;/div&gt;    )  }}</code></pre><p>现在，我们可以将任何子组件传递给 ToggleableMenu 组件:</p><pre><code>class Menu extends React.Component {  render() {    return (      &lt;div&gt;        &lt;ToggleableMenu title=&quot;First Menu&quot;&gt;          &lt;p&gt;Some content&lt;/p&gt;        &lt;/ToggleableMenu&gt;        &lt;ToggleableMenu title=&quot;Second Menu&quot;&gt;          &lt;p&gt;Another content&lt;/p&gt;        &lt;/ToggleableMenu&gt;        &lt;ToggleableMenu title=&quot;Third Menu&quot;&gt;          &lt;p&gt;More content&lt;/p&gt;        &lt;/ToggleableMenu&gt;      &lt;/div&gt;    )  }}</code></pre><p>如果你熟悉 Redux 的 connect 函数或者 React Router 的 withRouter 函数，那么你已经使用过高阶组件了。</p><h3 id="回调渲染组件"><a href="#回调渲染组件" class="headerlink" title="回调渲染组件"></a>回调渲染组件</h3><p>另一个比较高端的复用组件逻辑的方法是将函数作为组件的 props.children，该方法也称为 Function as Child Components。我们将使用渲染回调来重新实现上面的可扩展 Menu:</p><pre><code>class Toggleable extends React.Component {  constructor() {    super()    this.toggle = this.toggle.bind(this)    this.state = {show: false}  }  toggle() {    this.setState(prevState =&gt; ({ show: !prevState.show }))  }  render() {    return this.props.children(this.state.show, this.toggle)  }}</code></pre><p>现在，我们可以将函数作为组件的子级进行传递:</p><pre><code>&lt;Toggleable&gt;  {(show, onClick) =&gt; (    &lt;div&gt;      &lt;div onClick={onClick}&gt;        &lt;h1&gt;{props.title}&lt;/h1&gt;      &lt;/div&gt;      {show &amp;&amp; props.children}    &lt;/div&gt;  )}&lt;/Toggleable&gt;</code></pre><p>上面的代码已经将一个函数作为子组件，但是，若我们想复用上述逻辑，我们需要创建一个转换逻辑的新组件：</p><pre><code>const ToggleableMenu = props =&gt;  &lt;Toggleable&gt;    {(show, onClick) =&gt; (      &lt;div&gt;        &lt;div onClick={onClick}&gt;          &lt;h1&gt;{props.title}&lt;/h1&gt;        &lt;/div&gt;        {show &amp;&amp; props.children}      &lt;/div&gt;    )}  &lt;/Toggleable&gt;</code></pre><p>我们使用 Render Callbacks 实现的可扩展的 Menu 组件如下:</p><pre><code>class Menu extends React.Component {  render() {    return (      &lt;div&gt;        &lt;ToggleableMenu title=&quot;First Menu&quot;&gt;          &lt;p&gt;Some content&lt;/p&gt;        &lt;/ToggleableMenu&gt;        &lt;ToggleableMenu title=&quot;Second Menu&quot;&gt;          &lt;p&gt;Another content&lt;/p&gt;        &lt;/ToggleableMenu&gt;        &lt;ToggleableMenu title=&quot;Third Menu&quot;&gt;          &lt;p&gt;More content&lt;/p&gt;        &lt;/ToggleableMenu&gt;      &lt;/div&gt;    )  }}</code></pre><p>回调渲染组件 (Render Callbacks) 和高阶函数使我们的组件更加灵活，掌握和适应起来具有一定的难度，需要反复学习和消化。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> 组件模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中callee、caller、apply、call、bind的用法与区别</title>
      <link href="/articles/js%E4%B8%ADcallee%E3%80%81caller%E3%80%81apply%E3%80%81call%E3%80%81bind%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8C%BA%E5%88%AB.html"/>
      <url>/articles/js%E4%B8%ADcallee%E3%80%81caller%E3%80%81apply%E3%80%81call%E3%80%81bind%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8C%BA%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这五种方法经常用到，也经常看到，但是一直没有深入的理解它们直接的区别，为了不埋坑，重新学习总结一下。</p></blockquote><p>这五种方法大体可以分为两类，一类是callee,caller，另一类是call,apply,bind</p><h3 id="callee"><a href="#callee" class="headerlink" title="callee"></a>callee</h3><p>返回正被执行的 Function 对象，也就是所指定的 Function 对象的正文。</p><p>首先看一个斐波那契数列</p><pre><code>function factorial(num){  if(num&lt;=1){    return 1  }else{    return num*factorial(num-1)  }}</code></pre><p>这么看很完美，但是有一个问题就是递归的时候函数的执行与函数名紧紧的耦合在一起了，例如:</p><pre><code>var testFactorial = factorialfactorial = function(){  return 0}testFactorial(5) //0</code></pre><p>之所以是0的原因是factorial这个变量指向了return 0的这个匿名函数。</p><p>接下来我们用callee来对这个斐波那契数列进行解耦，目的很简单让函数里return指向自身</p><pre><code>function factorial(num){  if(num&lt;=1){    return 1;  }else{    return num*arguments.callee(num-1)  }}var testFactorial = factorial;factorial = function(){  return 0;}console.log(testFactorial(5)); //120</code></pre><p>这样以来就解决了刚才的问题</p><ul><li>callee 属性的初始值就是正被执行的 Function 对象。</li><li>callee 属性是 arguments 对象的一个成员，它表示对函数对象本身的引用，这有利于匿名函数的递归或者保证函数的封装性。</li></ul><h4 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h4><pre><code>// callee可以打印其本身function calleeDemo() {  alert(arguments.callee);}// 用于验证参数function calleeLengthDemo(arg1, arg2) {  if (arguments.length == arguments.callee.length) {    window.alert(&quot;验证形参和实参长度正确！&quot;);    return;  }else{    alert(&quot;实参长度：&quot; + arguments.length);    alert(&quot;形参长度： &quot; + arguments.callee.length);  }}// 递归计算var sum = function(n){  if (n &lt;= 0) {    return 1;  }else{    return n + arguments.callee(n - 1);  }}</code></pre><h3 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h3><p>返回一个对函数的引用，即调用了当前函数的函数体。</p><p>functionName.caller ：functionName 对象是所执行函数的名称。</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>对于函数来说，caller 属性只有在函数执行时才有定义。 如果函数是由JavaScript 程序的顶层调用的，那么 caller 包含的就是 null 。如果在字符串上下文中使用 caller 属性，那么结果和 functionName.toString 一样，也就是说，显示的是函数的反编译文本。</p><pre><code>function outer(){  inner();}function inner(){  console.log(inner.caller);}outer(); //显示outer的源代码</code></pre><p>因为outer()调用了inner()，所以inner.caller就指向outer()。为了实现松散的耦合也可以把inner.caller换成arguments.callee.caller。</p><h3 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h3><p>call和apply作用完全是一样的，区别也仅在于接受参数的方式不同。</p><p>apply第二个参数可以是Array的实例，也是一个argument对象，而call方法接收的第二个参数必须逐个列出来。 </p><p>call和apply是改变函数执行的作用域的，说的通俗点就是改变函数体内this的指向</p><pre><code>window.color = &apos;red&apos;var obj = {  color:&apos;blue&apos;}function sayColor(color){  console.log(this.color+&apos; param:&apos;+color)}sayColor.call(window,&apos;black&apos;); //red param:blacksayColor.apply(window,[&apos;black&apos;]);//red param:blacksayColor.call(obj,&apos;black&apos;) //blue param:blacksayColor.apply(obj,[&apos;black&apos;) //blue param:black</code></pre><p>这里面color存在在两个环境里，分别全局环境中和对象obj中。使用了call或apply方法后，接收的第一个参数就是改变this的指向，将this指向参数传入的作用域中去，因此输出了不同环境下的color值。 </p><p>使用apply和call的最大好处就是，对象不需要与方法有任何耦合关系。</p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind方法是ECMAscript5定义的一个方法。这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。</p><pre><code>window.color = &apos;red&apos;var obj = {  color:&apos;blue&apos;}function sayColor(color){  console.log(this.color)}var objSayColor = sayColor.bind(obj);objSayColor(); //blue</code></pre><p>bind方法会创建一个函数实例，因此需要有变量指向这个函数实例。使用bind的好处，除了能够解耦对象和方法外，在全局作用域中调用这个函数，也能够将this指向所对应的环境。</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> callee </tag>
            
            <tag> caller </tag>
            
            <tag> apply </tag>
            
            <tag> call </tag>
            
            <tag> bind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Promise那些事</title>
      <link href="/articles/%E5%85%B3%E4%BA%8EPromise%E9%82%A3%E4%BA%9B%E4%BA%8B.html"/>
      <url>/articles/%E5%85%B3%E4%BA%8EPromise%E9%82%A3%E4%BA%9B%E4%BA%8B.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Promise 的重要性不用多说, 曾经看到关于 JavaScript 的描述 — JS 的三座大山就是: 原型/作用域/异步, 所以如果说你是一个合格的 JavaScript 程序员, 这三块的内容肯定是要吃透的. 纵观 JavaScript 的异步史, 它经历了 callback -&gt; Promise -&gt; Generator -&gt; async-await 这样一个历程, 前前后后编写异步代码的变化. 从变化中就可以体会到, 确实越来越简洁, 越来越易读. 掌握它们, 你能写出更优雅的代码.</p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ECMAscript6 原生提供了 Promise 对象, 由浏览器直接支持, 目前大多数浏览器都已经实现了, 低版本浏览器可以使用 es6-promise 库来填平兼容性问题. Promise 最大的好处是把执行代码和处理代码分离开, 使异步操作逻辑更加清晰.</p><h3 id="Promise的特点"><a href="#Promise的特点" class="headerlink" title="Promise的特点"></a>Promise的特点</h3><p>1、对象的状态不受外界影响 Promise 对象代表一个异步操作, 有三种状态:</p><ul><li>pending - 初始状态</li><li>fulfilled - 操作成功完成</li><li>rejected - 操作失败</li></ul><p>2、一旦状态改变, 就不会再发生变化. Promise 对象的状态改变. 只有两种情况: 从 Pending 变为 Resolved 和从 Pending 变为 Rejected. 只要这两种情况发生, 状态就会固定, 不会再变了, 会一直保持这个结果, 与事件不同的是, 就算改变已经发生了, 再对 Promise 对象添加回调函数, 也会立即得到这个结果, 而事件一旦错过再去监听, 就不会得到结果.</p><p><img src="https://user-images.githubusercontent.com/10239097/47963292-f1a0d180-e064-11e8-8bd4-1c9b26ccafc2.png" alt="42730787-1d531df2-8830-11e8-8514-0a810d945440"></p><p>只有异步操作的结果可以决定当前是哪一种状态, 其他操作都不会影响状态改变, 这也是 Promise 最本质的特性, 对于调用者的一种承诺</p><h3 id="Promise-优缺点"><a href="#Promise-优缺点" class="headerlink" title="Promise 优缺点"></a>Promise 优缺点</h3><p>优点:</p><ul><li>可以将异步操作以同步操作的流程表达出来, 避免了层层嵌套的回调函数 Promise</li><li>对象提供统一的接口, 使得控制异步操作更加容易</li></ul><p>缺点:</p><ul><li>无法取消 Promise, 一旦新建它就会立即执行, 无法中途取消</li><li>如果不设置回调函数, Promise 内部抛出的错误, 不会反应到外部</li><li>当处于 Pending 状态时, 无法得知目前进展到哪一个阶段（刚刚开始或者即将完成）</li></ul><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h3><p>Promise.prototype.then 方法返回的是一个新的 Promise 对象, 因此可以采用链式写法</p><pre><code>ajax(&apos;http://some.api.com/&apos;) .then((json) =&gt; {    return json.post; }) .then((post) =&gt; {    // post 处理 });</code></pre><p>代码中使用了两个 then 方法, 分别指定了对应的回调参数. 第一个回调函数完成后, 会将返回结果作为参数, 传入第二个 then 中的回调函数执行.</p><pre><code>ajax(&apos;http://some.api.com/&apos;).then((jsonURL) =&gt; {  return ajax(jsonURL);}).then((post) =&gt; {  // post 处理});</code></pre><p>如果第一个回调函数返回的是 Promise 对象, 后一个回调函数会等待该 Promise 对象的运行结果, 等 Promise 运行结果返回, 再进一步调用. 这种设计使得嵌套的异步操作, 可以被很容易得改写, 把回调函数的 “横向发展” 改为了 “向下发展”.</p><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h3><p>Promise.prototype.catch 错误捕捉方法是 Promise.prototype.then(null, rejection) 的别名, 用来指定发生错误时的处理函数.</p><pre><code>ajax(&apos;http://some.api.com/&apos;).then((post) =&gt; {  throw Error();}).catch((error) =&gt; {  // 捕捉回调函数运行时发生的错误进行处理  console.log(&apos;error:&apos; + error);});</code></pre><p>Promise 对象的错误具有 “冒泡” 性质, 会一直向后传递, 直到被捕获为止.</p><pre><code>ajax(&apos;http://some.api.com/&apos;).then((jsonURL) =&gt; {  return ajax(jsonURL);}).then((comments) =&gt; {  throw Error();}).catch((error) =&gt; {  // 处理前两个回调函数的错误  console.log(&apos;error:&apos; + error);});</code></pre><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>Promise.resolve 方法可以将现有对象转为 Promise 对象. 如果 Promise.resolve 方法的参数, 不是 thenable 对象 (具有 then 方法的对象), 则返回一个新的 Promise 对象, 且它的状态为 fulfilled.</p><pre><code>const resolve = Promise.resolve(&apos;promise resolve&apos;);resolve.then((s) =&gt; {  console.log(s);});// outputpromise resolve</code></pre><p>如果 Promise 对象的实例状态为 fulfilled, 回调函数会立即执行, Promise.resolve 方法的参数就是回调函数的参数. 如果 Promise.resolve 方法的参数是一个 Promise 对象的实例, 则会返回该 Promise 实例.</p><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><p>Promise.reject(reason) 方法与 resolve 方法类似, 也会返回一个新的 Promise 实例, 但该实例的状态为 rejected. Promise.reject 方法的参数, 会被传递给实例的回调函数.</p><pre><code>const reject = Promise.reject(&apos;promise reject&apos;);reject.then(null, (err) =&gt; {  console.log(err)});// outputpromise reject</code></pre><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all 方法用于将多个 Promise 实例, 包装成一个新的 Promise 实例, 该方法一般接受一个数组作为参数, 但不一定是数组, 只要具有 iterator 接口. 且返回的每个成员都是 Promise 实例.</p><pre><code>const getRandom = () =&gt; +(Math.random() * 1000).toFixed(0);const ajax = (taskID) =&gt; new Promise(resolve =&gt; {  let timeout = getRandom();  console.log(`taskID=${taskID} start.`);  setTimeout(function() {    console.log(`taskID=${taskID} finished in time=${timeout}.`);    resolve(taskID)  }, timeout);});Promise.all([ajax(1), ajax(2), ajax(3)]).then(resultList =&gt; {  console.log(&apos;results:&apos;, resultList);});</code></pre><p>输出结果：</p><pre><code>taskID=1 start.taskID=2 start.taskID=3 start.taskID=2 finished in time=27.taskID=3 finished in time=257.taskID=1 finished in time=876.results: [1, 2, 3]</code></pre><p>Promise.all 状态分为两种:</p><ul><li>只有 ajax(1)、ajax(2)、ajax(3) 的状态都变成 fulfilled, Promise.all 返回的状态才会变成 fulfilled, 此时 ajax(1)、ajax(2)、ajax(3) 的返回值组成一个数组, 传递给 Promise.all 的回调函数.</li><li>只要 ajax(1)、ajax(2)、ajax(3) 之中有一个是 rejected, Promise.all 返回的状态就变成 rejected, 此时第一个被 reject 的实例的返回值, 会传递给 Promise.all 的回调函数.</li></ul><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race 方法也是将多个 Promise 实例, 包装成一个新的 Promise 实例, 与 Promise.all 不同的是一旦有状态改变, 就会返回第一个状态改变的 Promise 实例返回值.</p><pre><code>const getRandom = () =&gt; +(Math.random() * 1000).toFixed(0);const ajax = (taskID) =&gt; new Promise(resolve =&gt; {  let timeout = getRandom();  console.log(`taskID=${taskID} start.`);  setTimeout(function() {    console.log(`taskID=${taskID} finished in time=${timeout}.`);    resolve(taskID)  }, timeout);});Promise.race([ajax(1), ajax(2), ajax(3)]).then(result =&gt; {  console.log(&apos;results:&apos;, result);});</code></pre><p>输出结果：</p><pre><code>taskID=1 start.taskID=2 start.taskID=3 start.taskID=2 finished in time=59.results: 2taskID=3 finished in time=707.taskID=1 finished in time=854.</code></pre><p>Promise.race 虽然返回第一个状态改变的 Promise 实例 , 但不能阻止其他 Promise 实例状态改变.</p><p>如果 Promise.all 和 Promise.race 的参数不是 Promise 实例, 它们就会调用 Promise.resolve 方法, 将参数转为 Promise 实例, 再进一步处理.</p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式—javascript单例模式</title>
      <link href="/articles/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94javascript%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html"/>
      <url>/articles/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94javascript%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>保证一个类仅有一个实例，并且提供一个访问它的全局访问点。</p><h3 id="单例的实现"><a href="#单例的实现" class="headerlink" title="单例的实现"></a>单例的实现</h3><h4 id="传统语言描述的单例模式JavaScript实现"><a href="#传统语言描述的单例模式JavaScript实现" class="headerlink" title="传统语言描述的单例模式JavaScript实现"></a>传统语言描述的单例模式JavaScript实现</h4><pre><code>var SingleTon = function(name) {  this.name = name;  this.instance = null;};SingleTon.prototype.getName = function() {  alert(this.name);};SingleTon.getInstance = function(name) {  if(!this.instance){    this.instance = new SingleTon(name);  }  return this.instance;};var a = SingleTon.getInstance(&apos;seven1&apos;);var b = SingleTon.getInstance(&apos;seven2&apos;);</code></pre><h4 id="JavaScript的单例模式实现"><a href="#JavaScript的单例模式实现" class="headerlink" title="JavaScript的单例模式实现"></a>JavaScript的单例模式实现</h4><p>实现原理：利用闭包来保持对一个局部变量的引用，这个变量保存着首次创建的唯一的实例</p><pre><code>SingleTon.getSingle = (function(){    var instance = null;  return function(name){    if(!instance){      instance = new SingleTon(name);    }    return instance;  }})(); </code></pre><h3 id="单例的运用"><a href="#单例的运用" class="headerlink" title="单例的运用"></a>单例的运用</h3><h4 id="惰性单例模式"><a href="#惰性单例模式" class="headerlink" title="惰性单例模式"></a>惰性单例模式</h4><p>只在需要的时候才创建该单例</p><pre><code>var SingleTon = function(foo){  var instance = null;  return function(){    return instance || (instance = foo.apply(this,arguments));  }}; var createLoginLayer=(function(){  var div;  return function(){    if(!div){      div=document.createElement(&apos;div&apos;);    //创建一个登录框    }      return div;  }})();document.getElementById(&apos;loginBtn&apos;).onclick=function(){  var loginLayer=createLoginLayer();  loginLayer.style.display=&apos;block&apos;;};</code></pre><p>当用户第一次点击登录按钮时，来创建并显示登录窗口，之后重复点击按钮不会重复创建</p><h4 id="缓存函数的计算结果"><a href="#缓存函数的计算结果" class="headerlink" title="缓存函数的计算结果"></a>缓存函数的计算结果</h4><p>以下是不缓存的写法，非常慢！</p><pre><code>function foo(n){  results = n &lt; 2 ? n : foo(n - 1) + foo(n - 2);  return results;}console.log(foo(40)); //得计算好几秒 </code></pre><p>以下是缓存写法，基本瞬间出结果！</p><pre><code>var foo = (function(){var cache = {};return function(n){  if(!cache[n]){    cache[n] = n &lt; 2 ? n : foo(n - 1) + foo(n - 2);  }  return cache[n];};})();console.log(foo(100));</code></pre><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>单例模式可以提供一个命名空间，例如jQuery库的命名空间为jQuery或$。命名空间的使用是为了让代码更加整洁，在多人协作开发的情况下，不同的人定义的变量很有可能重复，此时就需要使用命名空间来约束每个人定义的变量，使相同名称的变量放在不同的命名空间中，避免相互干扰</p><pre><code>// A程序员的命名空间var A = {  get: function(id){    return document.getElementById(id);  }  css: function(id,key,value){    get(id).style[key] = value;  }}// B程序员的命名空间var B = {  get: function(className){    return document.getElementByClassName(className)[0];  }  css: function(className,key,value){    get(className).style[key] = value;  }}</code></pre><p>A、B两个命名空间中都有一个get方法和一个css方法，用于元素获取和元素样式修改，不同的是A是通过id来获取元素，而B是通过class来获取元素，通过命名空间，可以使这些相同名称的方法共存，使用时指定相应的命名空间即可。</p><h3 id="单例的优点与缺点"><a href="#单例的优点与缺点" class="headerlink" title="单例的优点与缺点"></a>单例的优点与缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>单例模式声明一个命名空间，它生成一个唯一的全局变量</p><p>在实现同一个功能的地方比通过new新创建对象对内存对资源的占用更据优势</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>它的扩展性不好，对一个单例对象里面的方法重写时会破坏原有的需求</p><p>灵活性不好， 当某个需要实现该功能的需求需要变动时，而其他的又不需要变动时，单例对象就不好处理了</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm包管理工具的使用</title>
      <link href="/articles/npm%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
      <url>/articles/npm%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<blockquote><p> 随着nodejs的发展，作为 node 自带的包管理工具的 npm 已经成为每个前端开发者必备的工具。但在日常使用中，往往只停留在npm install，遇到无法解决的问题时，只会删除node_modules 目录然后重新 install ，作为世界上最大规模的包管理系统，还有很多特性和方法需要学习。</p></blockquote><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>npm（node package manager）node的包管理工具，常见使用场景如下：</p></blockquote><ul><li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li><li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li><li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li></ul><h3 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h3><p><code>npm init</code> 命令用来初始化一个简单的 package.json 文件，package.json 文件是用来定义一个 package 的描述文件，执行该命令后终端会依次询问 name、version,、description 等字段。</p><p>如果不想手动去输入这些字段，直接采用默认内容，可以在命令后面追加–yes参数，和一路回车效果一样。</p><pre><code>npm init --yes</code></pre><h4 id="自定义-npm-init-行为"><a href="#自定义-npm-init-行为" class="headerlink" title="自定义 npm init 行为"></a>自定义 npm init 行为</h4><p>npm init 命令的原理就是调用脚本，输出一个初始化的 package.json 文件。在windows当前用户的目录下创建 .npm-init.js文件</p><blockquote><p>module.exports就是package.json的配置内容，使用prompt()可以获取用户输入</p></blockquote><pre><code>const desc = prompt(&apos;description?&apos;, &apos;A custom template...&apos;)const type = prompt(&apos;type?&apos;, &apos;&apos;)const user = prompt(&apos;user?&apos;, &apos;test&apos;)module.exports = {  key: &apos;value&apos;,  project: {    type: type,    user: user  },  name: prompt(&apos;name?&apos;, process.cwd().split(&apos;\\&apos;).pop()),  version: prompt(&apos;version?&apos;, &apos;0.1.0&apos;),  description: desc,  main: &apos;index.js&apos;,}</code></pre><p>在test目录下执行npm init，得到如下package.json文件</p><pre><code>{  &quot;key&quot;: &quot;value&quot;,  &quot;project&quot;: {    &quot;type&quot;: &quot;&quot;,    &quot;user&quot;: &quot;test&quot;  },  &quot;name&quot;: &quot;test&quot;,  &quot;version&quot;: &quot;0.1.0&quot;,  &quot;description&quot;: &quot;A custom template...&quot;,  &quot;main&quot;: &quot;index.js&quot;}</code></pre><p>除了生成 package.json，还可以执行node 脚本可以执行的任务。例如通过 fs 创建 README、.eslintrc 等项目必需文件，实现项目脚手架的作用。</p><h3 id="依赖包安装"><a href="#依赖包安装" class="headerlink" title="依赖包安装"></a>依赖包安装</h3><p>npm的核心功能，就是执行 npm install 从 package.json 中的 dependencies、devDependencies 将依赖包安装到当前目录的 ./node_modules 文件夹中。</p><p>默认配置下npm会从默认的源 (Registry) 中查找该包名对应的包地址，并下载安装。除了简单的指定包名，package还可以是一个指向有效包名的http、url/git、url/文件夹路径。</p><h4 id="引用本地模块"><a href="#引用本地模块" class="headerlink" title="引用本地模块"></a>引用本地模块</h4><p>1、在项目根目录创建要引用的模块，customerConfig文件夹，在文件夹内部新建index.js，和package.json文件，package.json文件内容如下：</p><pre><code>{    &quot;name&quot;: &quot;customerConfig&quot;,    &quot;main&quot;: &quot;index.js&quot;,    &quot;version&quot;: &quot;0.1.0&quot;}</code></pre><p>2、在项目的package.json文件中添加依赖项</p><pre><code>&quot;dependencies&quot;: {   &quot;customerConfig&quot;: &quot;file:./customerConfig&quot;}</code></pre><p>3、执行<code>npm install</code>或者<code>npm install file:./customerConfig</code></p><p>查看 node_modules 目录会发现多出来一个名为customerConfig，指向上层customerConfig文件夹的软链接。这是因为npm识别file:协议的url，得知这个包需要直接从文件系统中获取，会自动创建软链接到 node_modules 中，完成“安装”过程。</p><h4 id="引用私有-git-共享-package"><a href="#引用私有-git-共享-package" class="headerlink" title="引用私有 git 共享 package"></a>引用私有 git 共享 package</h4><p>我们可以把被依赖的包托管在私有的git仓库中，然后将该git url保存到dependencies中，npm会直接调用系统的 git命令从git仓库拉取包的内容到node_modules中。</p><pre><code>&lt;protocol&gt;://[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:][/]&lt;path&gt;[#&lt;commit-ish&gt; | #semver:&lt;semver&gt;]</code></pre><p>例如：</p><pre><code>git+ssh://git@github.com:npm/npm.git#v1.0.27git+ssh://git@github.com:npm/npm#semver:^5.0git+https://isaacs@github.com/npm/npm.gitgit://github.com/npm/npm.git#v1.0.27</code></pre><h3 id="npm-script的使用"><a href="#npm-script的使用" class="headerlink" title="npm script的使用"></a>npm script的使用</h3><p>npm 可以在项目package.json里面自定义脚本命令</p><pre><code>// package.json文件{  &quot;script&quot;:{    &quot;dev&quot;: &quot;webpack -w&quot;  }}</code></pre><p>package.json文件中的字段script的每一个属性都是一个自定义的脚本命令。</p><p>在命令行中可以通过执行npm run dev来执行这段脚本。</p><h4 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h4><p>使用npm run script执行脚本的时候都会创建一个shell，然后在shell中执行指定的脚本。</p><p>这个shell会将当前项目的可执行依赖目录（即node_modules/.bin）添加到环境变量path中，当执行之后之后再恢复原样。就是说脚本命令中的依赖名会直接找到node_modules/.bin下面的对应脚本，而不需要加上路径。</p><h4 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h4><p>向 npm 脚本传入参数，要使用–标明。</p><pre><code>npm run test -- --grep=&quot;pattern&quot;</code></pre><p>可以将 –grep=”pattern” 参数传给 test 命令</p><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>一个npm脚本可以执行多个任务，这些任务之间可以指定不同的执行顺序。</p><pre><code>// &apos;&amp;&apos; 并行执行顺序，同时执行&quot;dev&quot;:&quot;node test.js &amp; webpack&quot;// &apos;&amp;&amp;&apos;继发顺序，执行前面之后才可以执行后面&quot;dev&quot;:&quot;node test.js &amp;&amp; webpack&quot;</code></pre><h4 id="顺序钩子"><a href="#顺序钩子" class="headerlink" title="顺序钩子"></a>顺序钩子</h4><p>npm脚本自带两个顺序钩子，’pre’ 和 ‘post’</p><pre><code>&quot;predev&quot;:&quot;node test_one.js&quot;,&quot;dev&quot;:&quot;node test_two.js&quot;,&quot;postdev&quot;:&quot;node test_three.js&quot;</code></pre><p>当执行<code>npm run dev</code>的时候默认就会执行</p><pre><code>npm run predev &amp;&amp; npm run dev &amp;&amp; npm run postdev</code></pre><h4 id="可以缩写的脚本命令"><a href="#可以缩写的脚本命令" class="headerlink" title="可以缩写的脚本命令"></a>可以缩写的脚本命令</h4><pre><code>npm start === npm run startnpm stop === npm run stopnpm test === npm run testnpm restart === npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start</code></pre><h4 id="使用package-json内部变量"><a href="#使用package-json内部变量" class="headerlink" title="使用package.json内部变量"></a>使用package.json内部变量</h4><p>通过npm_package_前缀，npm脚本可以拿到npm的内部变量</p><pre><code>// package.json:{  &quot;name&quot;:&quot;develop&quot;,  &quot;script&quot;:&quot;node test.js&quot;}test.js:console.log(process.env.npm_package_name) //develop</code></pre>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派安装centos7系统</title>
      <link href="/articles/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85centos7%E7%B3%BB%E7%BB%9F.html"/>
      <url>/articles/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85centos7%E7%B3%BB%E7%BB%9F.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>树莓派3安装centos7，学习linux</p></blockquote><img src="http://47.114.51.62/images/blog/Raspberry.png" width="600"><h3 id="一、安装前准备"><a href="#一、安装前准备" class="headerlink" title="一、安装前准备"></a>一、安装前准备</h3><ul><li>一张SD卡和读卡器（最少8G）</li><li>显示器、键盘</li><li><a href="http://mirror.centos.org/altarch/7/isos/armhfp/" target="_blank" rel="noopener">centos7 arm版</a></li><li><a href="https://sourceforge.net/projects/win32diskimager/" target="_blank" rel="noopener">烧录软件Win32DiskImager</a></li></ul><h3 id="二、下载centos7系统"><a href="#二、下载centos7系统" class="headerlink" title="二、下载centos7系统"></a>二、下载centos7系统</h3><img src="http://47.114.51.62/images/blog/centos7.jpg" width="600"><p>选择树莓派迷你版，网上很多教程都是说下载img格式的，这里最新版的已经不是了，而是raw格式</p><h3 id="三、系统安装步骤"><a href="#三、系统安装步骤" class="headerlink" title="三、系统安装步骤"></a>三、系统安装步骤</h3><p>1、格式化SD卡</p><p>2、启动Win32DiskImager</p><img src="http://47.114.51.62/images/blog/Win32DiskImager.jpg" width="500"><p>Win32DiskImager 默认只支持img格式的镜像，这里选择的时候选择<em>.</em>，就会展示出raw的文件，右侧选择要烧录的SD卡，开始写入</p><p>3、烧录成功后，将SD卡插入树莓派启动，初始登录用户名root，密码centos，输入时密码不可见</p><img src="http://47.114.51.62/images/blog/login.jpg" width="500"><p>到此，系统安装完成，需要做一些更改。</p><h3 id="四、扩展磁盘空间"><a href="#四、扩展磁盘空间" class="headerlink" title="四、扩展磁盘空间"></a>四、扩展磁盘空间</h3><p>树莓派装完系统后，默认认没有把整个存储空间拓展到整张TF卡中，所以SD卡空间利用不充分。</p><p>使用<code>df -h</code>查看储存空间</p><img src="http://47.114.51.62/images/blog/small-space.jpg" width="500"><p>在root用户家目录有个 README 文件，里面提供命令的方式自动扩展空间</p><img src="http://47.114.51.62/images/blog/operate.jpg" width="500"><p>按照文件中的命令执行<code>rootfs-expand</code></p><img src="http://47.114.51.62/images/blog/expand.jpg" width="500"><p>此时再执行<code>df -h</code>查看储存空间，发现剩余空间已经被扩展</p><img src="http://47.114.51.62/images/blog/space.jpg" width="500"><h3 id="五、连接wifi"><a href="#五、连接wifi" class="headerlink" title="五、连接wifi"></a>五、连接wifi</h3><p>树莓派3自带有wifi模块，连接wifi以后，我们就可以用远程ssh登录centos</p><p>使用NetworkManager自带的nmcli命令</p><pre><code>// 查看无线网卡是否已经成功驱动 nmcli // 我的无线网卡显示的是wlp3s0，表示已经成功驱动，如果看不到无线网卡名称，利用lspci（需要安装pciutils包）命令查 // 看自己的网卡型号，下载相应的驱动程序进行安装 // 配置无线网卡 nmcli dev wifi con “无线网络名称”  password “无线网络密码” name “任意连接名称（删除，修改时用）” // 利用nmcli查看连接信息，能看到IP地址表示连接成功 nmcli // 删除此次连接 nmcli c del “连接名称”</code></pre><h3 id="六、yum源配置"><a href="#六、yum源配置" class="headerlink" title="六、yum源配置"></a>六、yum源配置</h3><p>在网上搜了一圈，发现目前国内阿里、清华、网易都没有armfhp版的CentOS源，所以只能使用自带的源，好在速度勉强可以接受。至于EPEL源的话官方提供了一个未经质检或测试的自动建设EPEL源，使用方法如下</p><pre><code>vi /etc/yum.repos.d/epel.repo</code></pre><p>添加下列内容，这是一个基于fedora aarch64版的源，所以可以将epel.repo的内容改为上海交大的源</p><pre><code>[epel]name=Extra Packages for Enterprise Linux 7baseurl=http://ftp.sjtu.edu.cn/fedora/epel/7/aarch64/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</code></pre><p>配置好yum源之后就赶紧更新，在装点必要的编译工具吧</p><pre><code>yum update</code></pre><p>到此，centos的安装就先告一段落。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos7 </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中forEach、find、map、filter、reduce、every、some数组循环的区别</title>
      <link href="/articles/js%E4%B8%ADforEach%E3%80%81find%E3%80%81map%E3%80%81filter%E3%80%81reduce%E3%80%81every%E3%80%81some%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
      <url>/articles/js%E4%B8%ADforEach%E3%80%81find%E3%80%81map%E3%80%81filter%E3%80%81reduce%E3%80%81every%E3%80%81some%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在ES6中新增了很多对数组操作的快捷方法，新的方法高效、好用，不用什么都是for循环，代码更加优雅，但是初学的时候有点头大，感觉所有方法都很像，不清楚具体使用的区别在哪，专门总结一下。</p></blockquote><p><br></p><h4 id="1、forEach-没有返回值，只是让数组中的每个元素执行function的操作"><a href="#1、forEach-没有返回值，只是让数组中的每个元素执行function的操作" class="headerlink" title="1、forEach 没有返回值，只是让数组中的每个元素执行function的操作"></a>1、forEach 没有返回值，只是让数组中的每个元素执行function的操作</h4><pre><code>let arr = [1,2,3,4,5];arr.forEach((item,index)=&gt;{    console.log(item * 2);       //2,4,6,8,10})</code></pre><h4 id="2、find-返回数组中第一个满足条件的元素（查找）"><a href="#2、find-返回数组中第一个满足条件的元素（查找）" class="headerlink" title="2、find 返回数组中第一个满足条件的元素（查找）"></a>2、find 返回数组中第一个满足条件的元素（查找）</h4><pre><code>let arr = [1,2,3,4,5];arr.find((item,index)=&gt;{    return item &gt; 3;       //4})</code></pre><h4 id="3、map-返回一个新数组，数组中的每个元素为调用function的结果"><a href="#3、map-返回一个新数组，数组中的每个元素为调用function的结果" class="headerlink" title="3、map 返回一个新数组，数组中的每个元素为调用function的结果"></a>3、map 返回一个新数组，数组中的每个元素为调用function的结果</h4><pre><code>let arr = [1,2,3,4,5];arr.map((item,index)=&gt;{    return item * 2;       //[2,4,6,8,10]})</code></pre><h4 id="4、filter-返回一个符合function条件的元素数组（过滤）"><a href="#4、filter-返回一个符合function条件的元素数组（过滤）" class="headerlink" title="4、filter 返回一个符合function条件的元素数组（过滤）"></a>4、filter 返回一个符合function条件的元素数组（过滤）</h4><pre><code>let arr = [1,2,3,4,5];arr.filter((item,index)=&gt;{    return item &gt; 3;       //[4,5]})</code></pre><h4 id="5、reduce-让数组中的前项和后项做某种运算，返回累计的最终值"><a href="#5、reduce-让数组中的前项和后项做某种运算，返回累计的最终值" class="headerlink" title="5、reduce 让数组中的前项和后项做某种运算，返回累计的最终值"></a>5、reduce 让数组中的前项和后项做某种运算，返回累计的最终值</h4><pre><code>let arr = [1,2,3,4,5];arr.reduce((prev,next)=&gt;{    return prev + next;       //15})</code></pre><h4 id="6、every-返回一个Boolean值，判断数组中每一个元素是否符合function的条件"><a href="#6、every-返回一个Boolean值，判断数组中每一个元素是否符合function的条件" class="headerlink" title="6、every 返回一个Boolean值，判断数组中每一个元素是否符合function的条件"></a>6、every 返回一个Boolean值，判断数组中每一个元素是否符合function的条件</h4><pre><code>let arr = [1,2,3,4,5];arr.every((item,index)=&gt;{    return item &gt; 0;       //true(所有元素都满足才为true)})</code></pre><h4 id="7、some-返回一个Boolean值，判断数组中是否有元素符合function的条件"><a href="#7、some-返回一个Boolean值，判断数组中是否有元素符合function的条件" class="headerlink" title="7、some 返回一个Boolean值，判断数组中是否有元素符合function的条件"></a>7、some 返回一个Boolean值，判断数组中是否有元素符合function的条件</h4><pre><code>let arr = [1,2,3,4,5];arr.some((item,index)=&gt;{    return item &gt; 4;       //true(只要有一个满足即可)})</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端开发踩过的坑</title>
      <link href="/articles/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91.html"/>
      <url>/articles/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>移动端h5的项目，大大小小也做了一些，遇到过不少问题，也踩过很多的坑，在这里总结一下，以备不时之需。</p></blockquote><h3 id="一、vue列表渲染track-by-”-index”"><a href="#一、vue列表渲染track-by-”-index”" class="headerlink" title="一、vue列表渲染track-by=”$index”"></a>一、vue列表渲染track-by=”$index”</h3><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><p>默认一般情况很少使用这个属性，但是在做评论列表时，需要实现一个提交即显示到列表的效果，所有采用了手动往列表数组中添加一条数组，而没有请求接口。如果不添加这个属性，添加的数据会替换原有位置的数据，而不会往数组中新增一个数据，Vue 不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素。</p><h4 id="属性说明："><a href="#属性说明：" class="headerlink" title="属性说明："></a>属性说明：</h4><p>无track-by情况：数据修改时，无论值是否被修改，dom都被重新渲染（控制台可以看到）</p><p>加入track-by属性：数据修改时，不变数据所在的dom不被重新渲染，已改变的数据所在dom才被重新渲染</p><table><tr><td bgcolor="#dddddd"><font color="red">注意：</font>track-by=”$index”是vue 1.x的属性，在vue 2中是在渲染列表时添加key属性，效果一样。这个问题其实官方文档中有说明，自己当时没认真看o(╥﹏╥)o</td></tr></table><p><br></p><h3 id="二、ios在键盘弹起后导致fixed定位失效问题"><a href="#二、ios在键盘弹起后导致fixed定位失效问题" class="headerlink" title="二、ios在键盘弹起后导致fixed定位失效问题"></a>二、ios在键盘弹起后导致fixed定位失效问题</h3><h4 id="问题描述：-1"><a href="#问题描述：-1" class="headerlink" title="问题描述："></a>问题描述：</h4><p>一般在留言列表一类的页面出现，当留言比较多，而且有分页的时候，当输入框获取焦点，弹出系统键盘，webview高度重新计算，会导致输入框的fixed定位失效，导致输入框可以向上滑动。属ios兼容性问题，安卓不会出现。</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>当输入法弹出时，给外层的包裹层添加</p><pre><code>height:100%;overflow:hidden;</code></pre><p>即可解决该问题。</p><p><br></p><h3 id="三、识别输入框中的换行"><a href="#三、识别输入框中的换行" class="headerlink" title="三、识别输入框中的换行"></a>三、识别输入框中的换行</h3><h4 id="问题描述：-2"><a href="#问题描述：-2" class="headerlink" title="问题描述："></a>问题描述：</h4><p>javascript获取到textarea文本框中的字符串中，如果包含有回车换行符，在字符串中表现为“\n”。</p><h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h4><pre><code>comment.replace(/\n/g,&quot;&lt;br /&gt;&quot;)</code></pre><p>将内容中的‘\n’替换成为<code>&lt;br&gt;</code></p><p><br></p><h3 id="四、https的新页面路由地址，在支付宝和uc浏览器当中无法识别"><a href="#四、https的新页面路由地址，在支付宝和uc浏览器当中无法识别" class="headerlink" title="四、https的新页面路由地址，在支付宝和uc浏览器当中无法识别"></a>四、https的新页面路由地址，在支付宝和uc浏览器当中无法识别</h3><h4 id="问题描述：-3"><a href="#问题描述：-3" class="headerlink" title="问题描述："></a>问题描述：</h4><p>在用vue开发一个扫码访问的h5的时候，在支付宝和uc浏览器当中无法识别新页面的路由地址</p><h4 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a>解决方案：</h4><p>传到正式环境之后就可以扫码访问了</p><p><br></p><h3 id="五、不定宽水平居中问题"><a href="#五、不定宽水平居中问题" class="headerlink" title="五、不定宽水平居中问题"></a>五、不定宽水平居中问题</h3><h4 id="解决方案：-3"><a href="#解决方案：-3" class="headerlink" title="解决方案："></a>解决方案：</h4><pre><code>display:table;   //重点就是这个属性，这个样式会告知浏览器当前元素的宽度，采用最小的宽度，不是默认全宽margin:0 auto;</code></pre><p><br></p><h3 id="六、安卓手机上文字无法垂直居中"><a href="#六、安卓手机上文字无法垂直居中" class="headerlink" title="六、安卓手机上文字无法垂直居中"></a>六、安卓手机上文字无法垂直居中</h3><h4 id="问题描述：-4"><a href="#问题描述：-4" class="headerlink" title="问题描述："></a>问题描述：</h4><p>rem的值为奇数时，会导致样式出错，文字无法垂直居中问题（font-size、line-height、padding等属性）</p><h4 id="解决方案：-4"><a href="#解决方案：-4" class="headerlink" title="解决方案："></a>解决方案：</h4><p>使用rem单位时尽量使用偶数，如0.6rem、0.8rem等</p><p><br></p><h3 id="七、ios11中，内嵌在app里的h5页面，快速滑动出现空白卡顿"><a href="#七、ios11中，内嵌在app里的h5页面，快速滑动出现空白卡顿" class="headerlink" title="七、ios11中，内嵌在app里的h5页面，快速滑动出现空白卡顿"></a>七、ios11中，内嵌在app里的h5页面，快速滑动出现空白卡顿</h3><h4 id="问题描述：-5"><a href="#问题描述：-5" class="headerlink" title="问题描述："></a>问题描述：</h4><p>app里面有一个内嵌的h5页面，页面已经加载完成，滑动也没有分页，上下来回滑动的过程中，当被遮住的部分重现滑出来的时候会空白，然后重新渲染出来，闪一下，但是同样的h5页面在微信或外部浏览器打开则没有这个问题</p><h4 id="解决方案：-5"><a href="#解决方案：-5" class="headerlink" title="解决方案："></a>解决方案：</h4><p>搜索了一圈发现我们ios客户端使用的是UIWebView，而换成WKWebView后这个问题就好了</p><p><br></p><h3 id="八、iPhoneX适配"><a href="#八、iPhoneX适配" class="headerlink" title="八、iPhoneX适配"></a>八、iPhoneX适配</h3><pre><code>// 1.viewport meta 标签增加属性viewport-fit=cover&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, viewport-fit=cover, xxxx&quot;&gt;// 2.body元素增加样式body {padding-bottom: constant(safe-area-inset-bottom);padding-bottom: env(safe-area-inset-bottom);}// 3.如有fixed底部的元素，也增加上面样式xxx {padding-bottom: constant(safe-area-inset-bottom);padding-bottom: env(safe-area-inset-bottom);background-color: #fff; // 记得添加background-color，不然会出现透明镂空的情况}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue开发遇到的微信支付授权目录的坑</title>
      <link href="/articles/vue%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%88%E6%9D%83%E7%9B%AE%E5%BD%95%E7%9A%84%E5%9D%91.html"/>
      <url>/articles/vue%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%88%E6%9D%83%E7%9B%AE%E5%BD%95%E7%9A%84%E5%9D%91.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>项目中要在微信底下开发单页应用(SPA)，前端技术选型用的vuejs+vue-router，vue-router使用hashbang模式（使用hashbang也是为了避免微信jssdk的wx.config签名的坑）。在调用微信支付的时候遇到提示“URL未注册”，这通常是因为没有在微信支付后台正确配置授权目录的问题，但我所遇到的并非如此。</p></blockquote><p>我们的应用中有5个页面用到微信支付：</p><pre><code>http://example.comhttp://example.com/#!/http://example.com/#!/cart/indexhttp://example.com/#!/order/orderlisthttp://example.com/#!/order/orderinfo</code></pre><p>微信支付允许配置5个目录为授权目录，另外允许配置一个测试环境目录，授权目录必须配置到最后一级目录，配置在根目录不行。到这里其实还都不是问题，问题是微信判断当前路径的方式。</p><p>我们先定义两个名词：首先把当前页面叫做“Current Page”；当我们从微信别的地方点击链接呼出微信浏览器时所落在的页面、或者点击微信浏览器的刷新按钮时所刷新的页面，我们叫做“Landing Page”。举个例子，我们从任何地方点击链接进入页面A，然后依次浏览到B、C、D，那么Current Page就是D，而Landing Page是A，如果此时我们在D页面点击一下浏览器的刷新按钮，那么Landing Page就变成了D（以上均是在单页应用的环境下，即以hashbang模式通过js更改浏览器路径，直接href跳转的不算）。</p><p>问题来了，在ios和安卓下呼出微信支付的时候，微信支付判断当前路径的规则分别是：</p><ul><li><strong>IOS：Landing Page</strong></li><li><strong>安卓：Current Page</strong></li></ul><p>这个规则是我试了N次试出来的，非常的坑，这就意味着，在ios环境下，任何一个页面都有可能成为支付页面（因为我无法预知和控制用户在哪个页面点微信浏览器的刷新按钮，或是用户通过哪个连接从外部进入到系统）。我在网上用了各种方式搜索这个问题的解决方案，都没找到好的，有关这个问题的帖子都少之又少，都只有吐槽它而没有解决了的。</p><p>这个问题虽然有一个解决方案，就是进入到支付页面的时候使用href跳转的方式，会造成页面刷新，影响一些用户体验，但是并不完美。</p><p>后来在网上看到一个思路，我们做的既然是单页应用，那么支付目录完全可以忽略井号“#”后面的hash路径</p><pre><code>http://example.com/</code></pre><p>然后我们在跳转的链接中，给井号前面叫一个问号“?”，如下</p><pre><code>http://example.com/?#!/cart/index</code></pre><p>这样微信浏览器就妥妥的把井号“#”后面的内容给忽略掉，从而达到了我们的目的</p>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信支付 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记之-对象</title>
      <link href="/articles/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%AF%B9%E8%B1%A1.html"/>
      <url>/articles/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%AF%B9%E8%B1%A1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>对象对于Javascript是非常重要的。在ES6中对象有了很多新特性。</p></blockquote><h3 id="对象的函数解构"><a href="#对象的函数解构" class="headerlink" title="对象的函数解构"></a>对象的函数解构</h3><p>我们在前后端分离时，后端经常返回来JSON格式的数据，前端的美好愿望是直接把这个JSON格式数据当作参数，传递到函数内部进行处理。ES6就为我们提供了这样的解构赋值。</p><pre><code>let json = {    a:&apos;js&apos;,    b:&apos;ps&apos;}function fun({a,b=&apos;web&apos;}){   //给b设置默认值    console.log(a,b);}fun(json);</code></pre><p>是不是感觉方便了很多，我们再也不用一个个传递参数了。</p><h3 id="数组的函数解构"><a href="#数组的函数解构" class="headerlink" title="数组的函数解构"></a>数组的函数解构</h3><p>函数能解构JSON，那解构我们的数组就更不在话下了，我们看下边的代码。我们声明一个数组，然后写一个方法，最后用…进行解构赋值。</p><pre><code>let arr = [&apos;js&apos;,&apos;css&apos;,&apos;html&apos;];function fun(a,b,c){    console.log(a,b,c);}fun(...arr);</code></pre><h3 id="in的用法"><a href="#in的用法" class="headerlink" title="in的用法"></a>in的用法</h3><p>in是用来判断对象或者数组中是否存在某个值的。我们先来看一下用in如何判断对象里是否有某个值。</p><h3 id="对象判断"><a href="#对象判断" class="headerlink" title="对象判断"></a>对象判断</h3><pre><code>let obj={    a:&apos;js&apos;,    b:&apos;css&apos;}console.log(&apos;a&apos; in obj);  //true</code></pre><h3 id="数组判断"><a href="#数组判断" class="headerlink" title="数组判断"></a>数组判断</h3><p>先来看一下ES5判断的弊端，以前会使用length属性进行判断，为0表示没有数组元素。但是这并不准确，或者说真实开发中有弊端。</p><pre><code>let arr=[,,,,,];console.log(arr.length); //5</code></pre><p>上边的代码输出了5，但是数组中其实全是空值，这就是一个坑啊。那用ES6的in就可以解决这个问题。</p><pre><code>let arr=[,,,,,];console.log(0 in arr); //falselet arr1=[&apos;js&apos;,&apos;css&apos;];console.log(0 in arr1);  // true</code></pre><p>注意：这里的0指的是数组下标位置是否为空。</p><h3 id="对象赋值"><a href="#对象赋值" class="headerlink" title="对象赋值"></a>对象赋值</h3><p>ES6允许把声明的变量直接赋值给对象，我们看下面的例子。</p><pre><code>let name=&quot;coder&quot;;let skill= &apos;js&apos;;var obj= {name,skill};console.log(obj);</code></pre><h3 id="对象Key值构建"><a href="#对象Key值构建" class="headerlink" title="对象Key值构建"></a>对象Key值构建</h3><p>有时候我们会在后台取出key值，而不是我们前台定义好的，这时候我们如何构建我们的key值那。比如我们在后台取了一个key值，然后可以用[ ]的形式，进行对象的构建。</p><pre><code>let key=&apos;skill&apos;;var obj={    [key]:&apos;web&apos;}console.log(obj.skill);</code></pre><h3 id="Object-is-对象比较"><a href="#Object-is-对象比较" class="headerlink" title="Object.is(  ) 对象比较"></a>Object.is(  ) 对象比较</h3><p>对象的比较方法,以前进行对象值的比较，经常使用===来判断，比如下面的代码：</p><pre><code>var obj1 = {name:&apos;js&apos;};var obj2 = {name:&apos;js&apos;};console.log(obj1.name === obj2.name);//true</code></pre><p>那ES6为我们提供了is方法进行对比。</p><pre><code>var obj1 = {name:&apos;js&apos;};var obj2 = {name:&apos;js&apos;};console.log(obj1.name === obj2.name);//trueconsole.log(Object.is(obj1.name,obj2.name)); //true</code></pre><p>区分=== 和 is方法的区别是什么，看下面的代码输出结果。</p><pre><code>console.log(+0 === -0);  //trueconsole.log(NaN === NaN ); //falseconsole.log(Object.is(+0,-0)); //falseconsole.log(Object.is(NaN,NaN)); //true</code></pre><p>这里，===为同值相等，is()为严格相等。</p><h3 id="Object-assign-合并对象"><a href="#Object-assign-合并对象" class="headerlink" title="Object.assign(  )合并对象"></a>Object.assign(  )合并对象</h3><p>操作数组时我们经常使用数组合并，那对象也有合并方法，那就是assgin(  )。看一下啊具体的用法。</p><pre><code>var a={a:&apos;js&apos;};var b={b:&apos;css&apos;};var c={c:&apos;web&apos;};let d=Object.assign(a,b,c)console.log(d);</code></pre>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记之--数组操作</title>
      <link href="/articles/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C.html"/>
      <url>/articles/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>前端编程工作中对数组的操作是非常多的，如果你对数组操作的不好，就很难写出令人惊奇的程序，所以这次记录一下ES6新增的一些数组操作方法。</p></blockquote><h3 id="JSON数组格式转换成数组"><a href="#JSON数组格式转换成数组" class="headerlink" title="JSON数组格式转换成数组"></a>JSON数组格式转换成数组</h3><p>JSON的数组格式就是为了前端快速的把JSON转换成数组的一种格式，我们先来看一下JSON的数组格式怎么写。</p><pre><code>let  json = {    &apos;0&apos;: &apos;html&apos;,    &apos;1&apos;: &apos;css&apos;,    &apos;2&apos;: &apos;javascript&apos;,    length:3}</code></pre><p>这就是一个标准的JSON数组格式，跟普通的JSON对比是在最后多了一个length属性。只要是这种特殊的json格式都可以轻松使用ES6的语法转变成数组。在ES6中绝大部分的Array操作都存在于Array对象里。我们就用Array.from(xxx)来进行转换。我们把上边的JSON代码转换成数组，并打印在控制台。</p><pre><code>let  json = {    &apos;0&apos;: &apos;html&apos;,    &apos;1&apos;: &apos;css&apos;,    &apos;2&apos;: &apos;javascript&apos;,    length:3}let arr=Array.from(json);console.log(arr)</code></pre><p>实际开发中这种方法还是比较常用的，毕竟节省了我们代码行数，也让我们的程序更清晰。</p><h3 id="Array-of-方法"><a href="#Array-of-方法" class="headerlink" title="Array.of()方法"></a>Array.of()方法</h3><p>它可以把一堆文本或者数字转换成数组。</p><pre><code>let arr =Array.of(3,4,5,6);console.log(arr);</code></pre><p>这个方法的主要目的是为了弥补数组构造函数Array()的不足，因为参数个数的不同，会导致Array()的行为有差异</p><pre><code>Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8]</code></pre><p>上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p><p>Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p><pre><code>Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2]</code></pre><p>Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p><p>当然它不仅可以转换数字，字符串也是可以转换的，看下边的代码：</p><pre><code>let arr =Array.of(&apos;html&apos;,&apos;css&apos;,&apos;javascript&apos;);console.log(arr);</code></pre><h3 id="find-实例方法"><a href="#find-实例方法" class="headerlink" title="find()实例方法"></a>find()实例方法</h3><p>所谓实例方法就是并不是以Array对象开始的，而是必须有一个已存在的数组实例，然后在使用的方法。</p><p>这里find()实例方法，用于找出数组中第一个符合条件的数组成员。如何没找到则返回undefined，它的参数是一个回调函数：</p><ul><li>value： 当前的值</li><li>index： 当前的位置</li><li>arr： 当前的数组</li></ul><p>所有数组成员依次执行该回调函数，直到找到第一个返回值为true的成员，然后返回该成员。</p><pre><code>let arr = [1,2,3,4,5];arr.find(function(value,index,arr){    return value &gt; 3;})</code></pre><p>上面的代码会打印出4，说明找到了数组中第一个大于3的值，并且返回。</p><h3 id="fill-实例方法"><a href="#fill-实例方法" class="headerlink" title="fill()实例方法"></a>fill()实例方法</h3><p>fill方法使用指定的值，填充数组。它可以传入三个参数，</p><pre><code>fill(value, startIndex, endIndex);</code></pre><p>第一个参数为填充的值，第二个参数为填充的起始位置，第三个参数为填充结束的位置（该位置的值不会填充），且后两个参数可省略，表示数组所有成员都被替换</p><pre><code>let arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];arr.fill(3,1,2);console.log(arr); //[&apos;a&apos;,3,&apos;c&apos;,&apos;d&apos;]</code></pre><p>arr数组中的下标为1的成员被替换成3，再试试省略后两个参数</p><pre><code>let arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];arr.fill(3);console.log(arr); //[3,3,3,3]</code></pre><p>数组的所有成员都被替换成了3</p><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>1.for…of循环</p><pre><code>let arr=[&apos;html&apos;,&apos;css&apos;,&apos;javascript&apos;]for (let item of arr){    console.log(item);}</code></pre><p>遍历数组的索引</p><pre><code>let arr=[&apos;html&apos;,&apos;css&apos;,&apos;javascript&apos;]for (let index of arr.keys()){    console.log(index);}</code></pre><p>遍历数组的索引和内容，这里需要entries()方法的配合,entries()是对键值对的遍历</p><pre><code>let arr=[&apos;html&apos;,&apos;css&apos;,&apos;javascript&apos;]for (let [index,val] of arr.entries()){    console.log(index,val);}</code></pre><p>2.forEach</p><pre><code>let arr = [&apos;sp&apos;,&apos;ps&apos;,&apos;web&apos;];arr.forEach((val, index) =&gt; console.log(index,val));</code></pre><p>3.filter</p><pre><code>let arr = [&apos;sp&apos;,&apos;ps&apos;,&apos;web&apos;];arr.filter((val, index) =&gt; console.log(index,val));</code></pre><p>4.some</p><pre><code>let arr = [&apos;sp&apos;,&apos;ps&apos;,&apos;web&apos;];arr.some((val, index) =&gt; console.log(index,val));</code></pre><p>5.map </p><pre><code>let arr = [&apos;sp&apos;,&apos;ps&apos;,&apos;web&apos;];arr.map((val, index) =&gt; console.log(index,val));</code></pre>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记之--字符串模版</title>
      <link href="/articles/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E7%89%88.html"/>
      <url>/articles/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E7%89%88.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>ES6对字符串新增了操作，最重要的就是字符串模版，我们不用再像ES5中那样去拼接变量，而且还支持模版里有简单的计算操作。</p></blockquote><h3 id="字符串模版"><a href="#字符串模版" class="headerlink" title="字符串模版"></a>字符串模版</h3><p>先来看看在es5中字符串拼接操作</p><pre><code>let content = &quot;javascript&quot;;let str = &quot;I love &quot; + content + &quot; and html&quot;;console.log(str);</code></pre><p>ES5中我们必须使用<strong>+ content +</strong>的形式进行拼接，这样复杂，而且容易出错，ES6中不在需要使用单引号，而是使用<code></code>，这样的连接号，变量的拼接则是通过${content}，这样的的形式，下面我们对上面的代码进行改造</p><pre><code>let content = &apos;javascript&apos;;let str = `I love ${content} and html`;console.log(str);</code></pre><p>可以看到输出了同样的结果，而且这里面是支持html标签的，我们来试试</p><pre><code>let content = &apos;javascript&apos;;let str = `I love&lt;br/&gt; &lt;b&gt;${content}&lt;/b&gt; &lt;br/&gt;and html`;document.write(str);</code></pre><h4 id="对运算符的支持"><a href="#对运算符的支持" class="headerlink" title="对运算符的支持"></a>对运算符的支持</h4><pre><code>let a = 1;let b = 2;let result = `${a+b}`;console.log(result);</code></pre><p>有了运算符的支持，在实际开发中，可以在后台写一个页面，直接输出给用户展示</p><h4 id="字符串的查找"><a href="#字符串的查找" class="headerlink" title="字符串的查找"></a>字符串的查找</h4><p>ES6中新增了字符串的查找，而且还支持中文的查找，这点还是非常的棒，下面我们看一个例子</p><pre><code>let str = &apos;欢迎学习ES6的字符串查找功能&apos;;console.log(str.includes(&apos;查找&apos;)); //true</code></pre><p>查找结果会直接返回true或者false，这样更加方便，直观；</p><h4 id="判断开头是否存在"><a href="#判断开头是否存在" class="headerlink" title="判断开头是否存在"></a>判断开头是否存在</h4><pre><code>console.log(b.startsWith(&apos;查找&apos;));  //开头</code></pre><h4 id="判断结尾是否存在"><a href="#判断结尾是否存在" class="headerlink" title="判断结尾是否存在"></a>判断结尾是否存在</h4><pre><code>console.log(b.endsWith(&apos;查找&apos;));  //开头</code></pre><p>有一点需要注意一下，starts和ends后面都要加s，千万不要漏掉了 </p><h4 id="复制字符串"><a href="#复制字符串" class="headerlink" title="复制字符串"></a>复制字符串</h4><p>有时候我们需要字符串重复，比如分隔符或者特殊符号，这时候就可以派上用场了</p><pre><code>document.write(&apos;js|&apos;.repeat(5));</code></pre>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记之--扩展运算符和rest运算符</title>
      <link href="/articles/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8Crest%E8%BF%90%E7%AE%97%E7%AC%A6.html"/>
      <url>/articles/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8Crest%E8%BF%90%E7%AE%97%E7%AC%A6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一节学习变量的结构赋值，大大提高了开发效率，继续学习扩展运算符和rest运算符</p></blockquote><h3 id="对象扩展运算符（…）"><a href="#对象扩展运算符（…）" class="headerlink" title="对象扩展运算符（…）"></a>对象扩展运算符（…）</h3><p>在定义一个方法的时候，我们可以允许传入的参数是不确定的，这时候可以用对象扩展运算符来做参数，看一个简单的例子：</p><pre><code>function test(...arg){    console.log(arg[0]);    console.log(arg[1]);    console.log(arg[2]);}test(1,2,3);</code></pre><p>控制台会依次输出1,2,3，当打印未传入的参数时，会提示undefined</p><h4 id="扩展运算符的用处"><a href="#扩展运算符的用处" class="headerlink" title="扩展运算符的用处"></a>扩展运算符的用处</h4><p>可以利用扩展运算符实现数组的深拷贝，我们知道数组是属于引用类型，直接使用等号赋值，复制的其实一个对内存堆地址的引用，这就导致改变其中一个数组的值，另一个也会受到影响</p><pre><code>let arr = [1,2,3];let arr2 = arr;arr2.push(4);console.log(arr); //[1,2,3,4];</code></pre><p>可以看到，当我们改变arr2数组的值时，arr数组也被改变了，这是我们所不想的，可以利用扩展运算符来解决这个问题</p><pre><code>let arr1 = [1,2,3];let arr2 = [...arr1];arr2.push(4);console.log(arr1);  //[1,2,3]console.log(arr2);  //[1,2,3,4]</code></pre><p>现在我们看到arr2的改变并不会影响arr1，扩展运算符就解决了我们的问题</p><h3 id="rest运算符"><a href="#rest运算符" class="headerlink" title="rest运算符"></a>rest运算符</h3><p>rest运算符和对象扩展运算符其实很像，都是用…(三个点)来表示，先看一个例子</p><pre><code>function test(first,...arg){    console.log(arr.length);}test(1,2,3,4,5,6,7);</code></pre><p>控制台输入的参数长度为6，说明arr里面有6个数组元素，并没有包含first参数</p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 扩展运算符 </tag>
            
            <tag> rest运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记之--变量的结构赋值</title>
      <link href="/articles/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC.html"/>
      <url>/articles/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>对于ES6的了解一直停留在几个常用的知识点，没有深入完整的去学习，最近抽空看了一套教程，对ES6有了一个比较全面的理解，记录下来当做复习。</p></blockquote><h3 id="第1节：变量的解构赋值"><a href="#第1节：变量的解构赋值" class="headerlink" title="第1节：变量的解构赋值"></a>第1节：变量的解构赋值</h3><p>ES6允许按照一定的顺序，从对象和数组中提取值，对变量进行赋值，这被称为解构。这可以大大简化我们的赋值操作，使代码解构更加简洁，清晰。</p><p>以前对变量的赋值，只能直接指定值</p><pre><code>let a = 1;let b = 2;let c = 3;</code></pre><p>而现在我们可以通过数组解构来进行赋值</p><pre><code>let [a,b,c] = [1,2,3];console.log(a);  //1console.log(b);  //2console.log(c);  //3</code></pre><p>从上面的代码可以看出，变量会从数组中提取值，按照对应的顺序进行赋值</p><p>本质上，这种写法属于“模式匹配”，即等号左边和右边的模式相同，左边的变量就会被赋予对应的值，来看几个嵌套模式的赋值</p><pre><code>let [a,[b,c],d] = [1,[2,3],4];console.log(a);  //1console.log(b);  //2console.log(c);  //3console.log(d);  //4</code></pre><p>如果等号两边形式不一样，很可能会获得undefined或者直接报错</p><h4 id="解构的默认值"><a href="#解构的默认值" class="headerlink" title="解构的默认值"></a>解构的默认值</h4><p>解构赋值允许使用默认值</p><pre><code>let [a,b=2] = [1];console.log(a); //1console.log(b); //2</code></pre><p>右边没有赋值时，变量b会直接使用默认值2</p><pre><code>let [a,b=2] = [1,3];console.log(a); //1console.log(b); //3</code></pre><p>此时，b的默认值会被新的赋值覆盖</p><h3 id="第2节：对象的解构"><a href="#第2节：对象的解构" class="headerlink" title="第2节：对象的解构"></a>第2节：对象的解构</h3><p>解构同样可以应用于对象</p><pre><code>let {name,skill} = {name:&apos;慕城&apos;,skill:&apos;web&apos;};console.log(name); //慕城console.log(skill); //web</code></pre><p><font color="red"><strong>注意：</strong></font>对象的解构和数组有所不同，数组的元素是按次序排列的，变量的取值由它的位置决定，对象的元素没有次序，而是按照属性名确定，属性名相同，才能获取到正确的值。</p><h4 id="圆括号的使用"><a href="#圆括号的使用" class="headerlink" title="圆括号的使用"></a>圆括号的使用</h4><p>如果在使用对象解构之前定义了变量，这时候再解构就会出现错误</p><pre><code>let status;{status} = {status:&apos;error&apos;};console.log(status);</code></pre><p>上面这段代码会报错，要解决这个问题，只需要给解构语句外层加上圆括号</p><pre><code>let status;({status} = {status:&apos;error&apos;});console.log(status); //error</code></pre><h3 id="第3节：字符串的解构"><a href="#第3节：字符串的解构" class="headerlink" title="第3节：字符串的解构"></a>第3节：字符串的解构</h3><p>字符串也可以解构，此时字符串被转换成类似数组的对象</p><pre><code>let [a,b,c] = &apos;web&apos;;console.log(a); //wconsole.log(b); //aconsole.log(c); //b</code></pre>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 变量的结构赋值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>module.exports与export default的区别</title>
      <link href="/articles/module-exports%E4%B8%8Eexport-default%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
      <url>/articles/module-exports%E4%B8%8Eexport-default%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在学习构建vue项目的过程中，发现很多地方都用到了module.exports、export default，但是一直不理解二者的区别。弄清楚二者的关系之前，首先需要了解两个概念，CommonJS模块规范和ES6模块规范。</p></blockquote><h3 id="CommonJS模块规范"><a href="#CommonJS模块规范" class="headerlink" title="CommonJS模块规范"></a>CommonJS模块规范</h3><p><strong>Node</strong>应用由模块组成，采用CommonJS规范。</p><p>根据这个规范，每个文件都是一个模块，有自己的作用域，在一个文件里面定义变量、函数、类，都是私有的，对其他文件不可见。</p><p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p><pre><code>var x = 5;var addX = function (value) {    return value + x;};module.exports.x = x;module.exports.addX = addX;</code></pre><p>上面代码通过module.exports输出变量x和函数addX。</p><p>require方法用于加载模块。</p><pre><code>var example = require(&apos;./example.js&apos;);console.log(example.x); // 5console.log(example.addX(1)); // 6</code></pre><h3 id="exports-与-module-exports"><a href="#exports-与-module-exports" class="headerlink" title="exports 与 module.exports"></a>exports 与 module.exports</h3><p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p><pre><code>var exports = module.exports;</code></pre><p>于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在module.exports上添加一样。注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p><h3 id="ES6模块规范"><a href="#ES6模块规范" class="headerlink" title="ES6模块规范"></a>ES6模块规范</h3><p>不同于CommonJS，ES6使用 export 和 import 来导出、导入模块。</p><pre><code>var firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;var year = 1958;export {firstName, lastName, year};</code></pre><p>需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><pre><code>// 写法一export var m = 1;// 写法二var m = 1;export {m};// 写法三var n = 1;export {n as m};</code></pre><h3 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h3><p>使用export default命令，为模块指定默认输出。</p><pre><code>export default function () {    console.log(&apos;foo&apos;);}</code></pre><p>相关链接：<br>CommonJS规范：<a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/module.html</a><br>ES6 Module 的语法：<a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/module</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于setTimeout()的黑科技</title>
      <link href="/articles/%E5%85%B3%E4%BA%8EsetTimeout-%E7%9A%84%E9%BB%91%E7%A7%91%E6%8A%80.html"/>
      <url>/articles/%E5%85%B3%E4%BA%8EsetTimeout-%E7%9A%84%E9%BB%91%E7%A7%91%E6%8A%80.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前对setTimeout()的理解很浅显，在设定的时间后执行任务。偶尔也遇到过某些任务不执行时，使用setTimeout()就能解决，但是一直没有理解其中的原理，最近看到一篇文章<a href="http://caibaojian.com/about-settimeout.html" target="_blank" rel="noopener">《关于setTimeout()你所不知道的地方》</a>，梳理一下关于setTimeout()的知识点。</p></blockquote><h3 id="一、setTimeout基础用法"><a href="#一、setTimeout基础用法" class="headerlink" title="一、setTimeout基础用法"></a>一、setTimeout基础用法</h3><p>setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。</p><p><code>var timerId = setTimeout(func|code, delay)</code></p><p>setTimeout函数接受两个参数，第一个参数func|code是将要推迟执行的函数名或者一段代码，第二个参数delay是推迟执行的毫秒数。</p><pre><code>console.log(1);setTimeout(&apos;console.log(2)&apos;,1000);console.log(3);</code></pre><p>上面代码的运行结果是1,3,2，因为setTimeout指定第二行语句推迟1000毫秒再执行。</p><h3 id="二、setTimeout参数使用"><a href="#二、setTimeout参数使用" class="headerlink" title="二、setTimeout参数使用"></a>二、setTimeout参数使用</h3><p>向setTimeout()传递一个字符串时，javascript引擎会先使用eval函数，将字符串转换成为代码，然后再执行，一方面出于安全考虑，另一方面为了便于引擎优化代码，一般总是采用函数名形式。</p><pre><code>// 推荐window.setTimeout(function() {    alert(&quot;Hello World!&quot;);}, 500);// 不推荐window.setTimeout(&quot;alert(&quot;Hello World!&quot;);&quot;, 500);</code></pre><blockquote><p><strong>注意：这里不推荐将要延迟执行的代码以字符串的形式传入setTimeout(),最好以匿名函数的形式传入。</strong></p></blockquote><h3 id="三、对this指向的影响"><a href="#三、对this指向的影响" class="headerlink" title="三、对this指向的影响"></a>三、对this指向的影响</h3><p>setTimeout()回调函数中的this</p><p>如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的this关键字将指向全局环境，而不是定义时所在的那个对象。</p><pre><code>var x = 1;var test = {    x: 2,    app: function(){        console.log(this.x);    }};setTimeout(test.app,1000);// 1</code></pre><p>上面代码输出的是1，而不是2，这表示test.app的this所指向的已经不是o，而是全局环境了。</p><p>再看一个不容易发现错误的例子。</p><pre><code>function User(login) {    this.login = login;    this.sayHi = function() {        console.log(this.login);    }}var user = new User(&apos;hello world&apos;);setTimeout(user.sayHi, 1000);</code></pre><p>上面代码只会显示undefined，因为等到user.sayHi执行时，它是在全局对象中执行，所以this.login取不到值。</p><p>为了防止出现这个问题，一种解决方法是将user.sayHi放在匿名函数中执行。</p><pre><code>setTimeout(function() {    user.sayHi();}, 1000);</code></pre><p>上面代码中，sayHi是在user作用域内执行，而不是在全局作用域内执行，所以能够显示正确的值。</p><p>另一种解决方法是，使用bind方法，将绑定sayHi绑定在user上面。</p><pre><code>setTimeout(user.sayHi.bind(user), 1000);</code></pre><h3 id="四、setTimeout运行机制"><a href="#四、setTimeout运行机制" class="headerlink" title="四、setTimeout运行机制"></a>四、setTimeout运行机制</h3><p>setTimeout和setInterval的运行机制是，将指定的代码移出本次执行，等到下一轮Event Loop时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮Event Loop时重新判断。这意味着，setTimeout指定的代码，必须等到本次执行的所有代码都执行完，才会执行。</p><p>每一轮Event Loop时，都会将“任务队列”中需要执行的任务，一次执行完。setTimeout和setInterval都是把任务添加到“任务队列”的尾部。因此，它们实际上要等到当前脚本的所有同步任务执行完，然后再等到本次Event Loop的“任务队列”的所有任务执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。</p><pre><code>setTimeout(someTask,100);veryLongTask();</code></pre><p>上面代码的setTimeout，指定100毫秒以后运行一个任务。但是，如果后面立即运行的任务（当前脚本的同步任务）非常耗时，过了100毫秒还无法结束，那么被推迟运行的someTask就只有等着，等到前面的veryLongTask运行结束，才轮到它执行。</p><pre><code>setTimeout(function() {  console.log(&quot;Timeout&quot;);}, 0);function a(x) {  console.log(&quot;a() 开始运行&quot;);  b(x);  console.log(&quot;a() 结束运行&quot;);}function b(y) {  console.log(&quot;b() 开始运行&quot;);  console.log(&quot;传入的值为&quot; + y);  console.log(&quot;b() 结束运行&quot;);}console.log(&quot;当前任务开始&quot;);a(42);console.log(&quot;当前任务结束&quot;);// 当前任务开始// a() 开始运行// b() 开始运行// 传入的值为42// b() 结束运行// a() 结束运行// 当前任务结束// Timeout</code></pre><p>上面代码说明，setTimeout(f,0)必须要等到当前脚本的所有同步任务结束后才会执行。</p><h3 id="五、setTimeout的应用"><a href="#五、setTimeout的应用" class="headerlink" title="五、setTimeout的应用"></a>五、setTimeout的应用</h3><h4 id="5-1调整事件的发生顺序"><a href="#5-1调整事件的发生顺序" class="headerlink" title="5.1调整事件的发生顺序"></a>5.1调整事件的发生顺序</h4><p>setTimeout(f,0)有几个非常重要的用途。它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，我们先让父元素的事件回调函数先发生，就要用到setTimeout(f, 0)。</p><pre><code>var input = document.getElementsByTagName(&apos;input[type=button]&apos;)[0];input.onclick = function A() {  setTimeout(function B() {    input.value +=&apos; input&apos;;  }, 0)};document.body.onclick = function C() {  input.value += &apos; body&apos;};</code></pre><p>上面代码在点击按钮后，先触发回调函数A，然后触发函数C。在函数A中，setTimeout将函数B推迟到下一轮Loop执行，这样就起到了，先触发父元素的回调函数C的目的了。</p><p>用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，keypress事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。</p><pre><code>document.getElementById(&apos;input-box&apos;).onkeypress = function(event) {  this.value = this.value.toUpperCase();}</code></pre><p>上面代码想在用户输入文本后，立即将字符转为大写。但是实际上，它只能将上一个字符转为大写，因为浏览器此时还没接收到文本，所以this.value取不到最新输入的那个字符。只有用setTimeout改写，上面的代码才能发挥作用。</p><pre><code>document.getElementById(&apos;my-ok&apos;).onkeypress = function() {  var self = this;  setTimeout(function() {    self.value = self.value.toUpperCase();  }, 0);}</code></pre><p>上面代码将代码放入setTimeout之中，就能使得它在浏览器接收到文本之后触发;</p><h4 id="5-2分割耗时"><a href="#5-2分割耗时" class="headerlink" title="5.2分割耗时"></a>5.2分割耗时</h4><p>众所周知javascript是单线程的，特点就是容易出现阻塞。如果一段程序处理时间很长，很容易导致整个页面hold住。什么交互都处理不了怎么办？</p><blockquote><p>简化复杂度？复杂逻辑后端处理？html5的多线程？……</p></blockquote><p>上面都是ok的做法，但是setTimeout也是处理这种问题的一把好手。setTimeout一个很关键的用法就是分片，如果一段程序过大，我们可以拆分成若干细小的块。由于setTimeout(f,0)实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到setTimeout(f,0)里面执行(分片塞入队列)，这样即使在复杂程序没有处理完时，我们操作页面，也是能得到即时响应的。其实就是将交互插入到了复杂程序中执行。</p><pre><code>var div = document.getElementsByTagName(&apos;div&apos;)[0];// 写法一for(var i=0xA00000;i&lt;0xFFFFFF;i++) {  div.style.backgroundColor = &apos;#&apos;+i.toString(16);}// 写法二var timer;var i=0x100000;function func() {  timer = setTimeout(func, 0);  div.style.backgroundColor = &apos;#&apos;+i.toString(16);  if (i++ == 0xFFFFFF) clearInterval(timer);}timer = setTimeout(func, 0);</code></pre><p>上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，而写法二就能就不会，这就是setTimeout(f,0)的好处。即：可利用setTimeout实现一种伪多线程的概念。</p><h3 id="六-如何使用setTimeout"><a href="#六-如何使用setTimeout" class="headerlink" title="六, 如何使用setTimeout"></a>六, 如何使用setTimeout</h3><p>关于setTimeout()的使用远不止这些，但是足见其强大，那么问题来了，需要在项目中大量使用么？视个人和项目而定吧；如不能熟练掌握，不建议多用。毕竟在某些情景之下，setTimeout作为一个hack的方式而存在的。</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> setTimeout() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用操作命令</title>
      <link href="/articles/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4.html"/>
      <url>/articles/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近折腾博客，git命令使用的特别频繁，也新学会了不少命令，记录下来，以便后面自己查阅！</p></blockquote><h3 id="建立代码仓库"><a href="#建立代码仓库" class="headerlink" title="建立代码仓库"></a>建立代码仓库</h3><p><code>git init  //在本地建立代码仓库</code></p><p><code>git status  //列出变更文件</code></p><p><code>git add .  //将工作区所有修改添加到暂存区</code></p><p><code>git add filename  //将指定文件添加到暂存区</code></p><p><code>git commit -m &#39;备注信息&#39;    //将暂存区修改添加到本地仓库</code></p><h3 id="连接远程仓库，并将本地改动push到远程【注：pull-fetch-merge"><a href="#连接远程仓库，并将本地改动push到远程【注：pull-fetch-merge" class="headerlink" title="连接远程仓库，并将本地改动push到远程【注：pull=fetch+merge]"></a>连接远程仓库，并将本地改动push到远程【注：pull=fetch+merge]</h3><p><code>ssh-keygen -t ras -C &quot;your_email_name@xxx&quot;    //生成密钥</code></p><p><code>ssh -T git@github.com    //验证密钥是否添加成功</code>     </p><p><code>git remote add origin git@github.com:gitname/test.git    //远程地址   不要用https的，会导致每次都需要输入用户名和密码</code></p><p><code>git push origin branchname   //更新代码到github</code></p><p><code>git pull origin branchname   //同步远程代码到本地</code></p><p><code>git pull --rebase origin master   //解决冲突，先将本地改变暂存起来，恢复代码到上次pull之前，合并远端代码到本地，最后再合并刚刚暂存下來的本地变更</code></p><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><p><code>git rm filename   //删除本地暂存区文件</code></p><p><code>git checkout branchname    //切换分支</code></p><p><code>git branche name  //创建分支</code></p><p><code>git branch -d name   //删除本地分支</code></p><p><code>git push origin --delete &lt;branchName&gt;    //删除远程分支</code></p><p><code>git branch   //查看分支</code></p><p><code>git clone git@github.com:gitname/test.git    //拷贝仓库</code></p><p><code>git clone -b &lt;branchName&gt;    //拉取指定分支的代码</code> </p><p><code>git subtree push --prefix=dist origin gh-pages   //把本地dist目录推送到gh-pages分支，设置gitpage服务</code></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>material主题博客添加动态多边形背景</title>
      <link href="/articles/material%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%8A%A8%E6%80%81%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%83%8C%E6%99%AF.html"/>
      <url>/articles/material%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%8A%A8%E6%80%81%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%83%8C%E6%99%AF.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近从网上看到很多博客都有一个动态的多边形连线背景，觉得很好看，正好觉得自己的博客背景太单调，于是研究了下，方法如下。</p></blockquote><h3 id="修改主题文件layout-ejs"><a href="#修改主题文件layout-ejs" class="headerlink" title="修改主题文件layout.ejs"></a>修改主题文件layout.ejs</h3><p>打开material/layout/layout.ejs，在body后面添加代码</p><pre><code>&lt;% if (theme.canvas_nest) { %&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&lt;% } %&gt;</code></pre><h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><p>打开material/_config.yml，添加如下代码</p><pre><code># --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true</code></pre><p>OK,搞定！重新生成预览<code>hexo s -g</code>，打开localhost:4000就可以看见效果了</p><h3 id="如果对效果不满意，可以修改背景配置项"><a href="#如果对效果不满意，可以修改背景配置项" class="headerlink" title="如果对效果不满意，可以修改背景配置项"></a>如果对效果不满意，可以修改背景配置项</h3><pre><code>&lt;% if (theme.canvas_nest) { %&gt;    &lt;script type=&quot;text/javascript&quot; color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&lt;% } %&gt;</code></pre><h3 id="背景配置项"><a href="#背景配置项" class="headerlink" title="背景配置项"></a>背景配置项</h3><ul><li>color: 线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B)</li><li>opacity: 线条透明度（0~1）, 默认: 0.5</li><li>count: 线条的总数量, 默认: 150</li><li>zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1</li></ul>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> 背景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用chrome调试Android手机前端页面</title>
      <link href="/articles/%E4%BD%BF%E7%94%A8chrome%E8%B0%83%E8%AF%95Android%E6%89%8B%E6%9C%BA%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2.html"/>
      <url>/articles/%E4%BD%BF%E7%94%A8chrome%E8%B0%83%E8%AF%95Android%E6%89%8B%E6%9C%BA%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>很多时候在调试h5页面的时候，用浏览器模拟的效果和手机上面不一致，想要找到问题就比较麻烦，因为看不到手机中渲染出来的页面源码，这个时候如果可以在浏览器中看到并且直接调试的话，就会方便很多。</p></blockquote><h3 id="调试要求"><a href="#调试要求" class="headerlink" title="调试要求"></a>调试要求</h3><p>确保安卓手机和pc端都安装了chrome浏览器</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>1、开启手机的开发者选项，确保USB调试保持打开状态。（这里的截图来自vivo手机，其他手机大同小异）</p><img src="http://47.114.51.62/images/blog/setting.jpg" width="400"><p>2、用USB数据线连接手机和电脑，驱动安装好后，在手机上会显示一个允许USB调试的的确认框，点击确定。(好像只有第一次连接的时候会出现，后面就不会了，这部手机之前连过，所以没有截到图)</p><p>3、打开pc端chrome浏览器，在地址栏输入chrome://inspect/#devices，或者about:inspect。勾选 Discover USB devices，就可以看到手机设备了。</p><img src="http://47.114.51.62/images/blog/device.jpg" width="640"><p>4、打开手机端chrome浏览器，输入要调试的页面地址，点击inspect即可打开DevTools，界面和调试浏览器页面一样。</p><img src="http://47.114.51.62/images/blog/divece2.jpg" width="640"><img src="http://47.114.51.62/images/blog/inspect.jpg" width="640"><p>5、点击inspect后，如果遇到打开的是一个白屏界面，说明需要翻墙才能使用，一般情况下，第一次使用inspect时需要翻墙，以后就会缓存在本地。</p>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端rem布局样式错乱问题</title>
      <link href="/articles/%E7%A7%BB%E5%8A%A8%E7%AB%AFrem%E5%B8%83%E5%B1%80%E6%A0%B7%E5%BC%8F%E9%94%99%E4%B9%B1%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
      <url>/articles/%E7%A7%BB%E5%8A%A8%E7%AB%AFrem%E5%B8%83%E5%B1%80%E6%A0%B7%E5%BC%8F%E9%94%99%E4%B9%B1%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<p>这段时间在开发app内的h5页面，发现一个奇怪的问题，测试机中有一台oppo手机，在app打开h5之后，整个页面被压扁变形了，一开始以为是手机分辨率的问题，但是在同样的手机的其它app内和浏览器内打开页面，都是完全正常显示。  </p><p>于是判断应该是客户端那边的问题，找到安卓的开发人员，但是他说他们也没问题，是前端适配的问题，这就尴尬了，测试一直追着要解决这个问题。</p><p>后来查了一下，发现原来是手机字体大小设置的问题，当把字体调大一号时，在app内就正常显示了。现在很多安卓手机的系统都是可以自己去设置系统字体的大小，这就导致用rem布局时，根字体的大小计算错误，样式出现错乱。ios上不会出现这个问题。</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><blockquote><p>Android手机可以给webview配置webview.getSettings().setTextZoom(100)禁止缩放，按照百分百显示。</p></blockquote><p><br><strong>注意：</strong>rem布局在安卓手机中还有一个问题需要特别注意，很多按钮样式我们希望文字可以垂直居中，一般都是用line-height或者padding去处理，但是我们会发现在很多安卓手机里无法垂直居中，这里其实是我们设置的rem单位为奇数造成的。我们在设置font-size，line-height，padding等属性的值时，尽量都是偶数，这样就不会出现这个问题了！</p>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rem布局 </tag>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Blog</title>
      <link href="/articles/hello-blog.html"/>
      <url>/articles/hello-blog.html</url>
      
        <content type="html"><![CDATA[<p>想搭建一个自己的个人博客很久了，但是一直很懒没有去动，终于今天将博客搭建好了，比想象中要容易很多，有了属于自己的小窝，希望可以在这里记录自己学习生活的点点滴滴！</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="about.html"/>
      <url>about.html</url>
      
        <content type="html"><![CDATA[<h3 id="LONELY-MAN"><a href="#LONELY-MAN" class="headerlink" title="LONELY MAN"></a>LONELY MAN</h3>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>links</title>
      <link href="links/index.html"/>
      <url>links/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="tags/index.html"/>
      <url>tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>timeline</title>
      <link href="timeline/index.html"/>
      <url>timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
